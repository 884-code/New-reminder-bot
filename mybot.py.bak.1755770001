# -*- coding: utf-8 -*-
# mybot.py (failsafe setup edition)
import os, re, json, sqlite3, logging, asyncio
from datetime import datetime, timedelta
from typing import Optional, List

import discord
from discord import app_commands
from discord.ext import commands, tasks

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)-8s %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("bot.log", encoding="utf-8")]
)
logger = logging.getLogger("taskbot")

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.message_content = True

bot = commands.Bot(
    command_prefix=commands.when_mentioned_or("!", "ï¼", "/"),
    intents=intents,
    case_insensitive=True,
    help_command=None,
    max_messages=100,
)

DB_PATH = "reminder_bot.db"
def db_exec(q: str, params: tuple = (), fetch=False):
    conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
    cur.execute(q, params); rows = cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

def init_db():
    db_exec("""CREATE TABLE IF NOT EXISTS admins(user_id INTEGER, guild_id INTEGER, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS instructors(user_id INTEGER, guild_id INTEGER, target_users TEXT, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS tasks(
        id INTEGER PRIMARY KEY AUTOINCREMENT, guild_id INTEGER, instructor_id INTEGER, assignee_id INTEGER,
        task_name TEXT, due_date TIMESTAMP, status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        message_id INTEGER, channel_id INTEGER, reminder_sent INTEGER DEFAULT 0)""")
    cols = db_exec("PRAGMA table_info(tasks)", fetch=True)
    if "reminder_sent" not in [c[1] for c in cols]:
        db_exec("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")

def is_admin(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM admins WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))
def is_instructor(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM instructors WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))

def insert_task(gid:int,iid:int,aid:int,name:str,due:datetime)->int:
    db_exec("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date) VALUES (?,?,?,?,?)", (gid,iid,aid,name,due))
    return db_exec("SELECT last_insert_rowid()", fetch=True)[0][0]

def get_task(tid:int):
    r=db_exec("SELECT * FROM tasks WHERE id=?", (tid,), fetch=True)
    return r[0] if r else None

async def ensure_mgmt(guild:discord.Guild)->Optional[discord.TextChannel]:
    for name in ("task-management","ã‚¿ã‚¹ã‚¯ç®¡ç†"):
        ch = discord.utils.get(guild.channels, name=name)
        if isinstance(ch, discord.TextChannel): return ch
    try:
        return await guild.create_text_channel("task-management", overwrites={guild.default_role: discord.PermissionOverwrite(read_messages=False)})
    except Exception as e:
        logger.error(f"mgmt create failed: {e}"); return None

async def ensure_personal(guild:discord.Guild,user:discord.Member)->Optional[discord.TextChannel]:
    name=f"to-{user.display_name}".lower().replace(" ","-")
    ch=discord.utils.get(guild.channels,name=name)
    if isinstance(ch,discord.TextChannel): return ch
    try:
        ow={guild.default_role: discord.PermissionOverwrite(read_messages=False), user: discord.PermissionOverwrite(read_messages=True, send_messages=True)}
        return await guild.create_text_channel(name=name, overwrites=ow, topic=f"{user.display_name} ã®å€‹äººã‚¿ã‚¹ã‚¯")
    except Exception as e:
        logger.error(f"personal create failed: {e}"); return None

def parse_date(s:str)->Optional[datetime]:
    now=datetime.now(); t=s.strip().lower()
    m=re.search(r'(\d{1,2}):(\d{2})$',t)
    if m: hour,minute=int(m.group(1)),int(m.group(2)); t=t[:m.start()].strip()
    else: hour,minute=23,59
    pats=[(r'^(ä»Šæ—¥|today)$',lambda m:now),(r'^(æ˜æ—¥|tomorrow)$',lambda m:now+timedelta(days=1)),
          (r'^(æ˜å¾Œæ—¥|day after tomorrow)$',lambda m:now+timedelta(days=2)),(r'^(æ˜¨æ—¥|yesterday)$',lambda m:now-timedelta(days=1)),
          (r'^(\d+)\s*(æ—¥å¾Œ|days?)$',lambda m:now+timedelta(days=int(m.group(1)))),
          (r'^(\d+)\s*(é€±é–“å¾Œ|weeks?)$',lambda m:now+timedelta(weeks=int(m.group(1)))),
          (r'^(\d+)\s*(æ™‚é–“å¾Œ|hours?)$',lambda m:now+timedelta(hours=int(m.group(1)))),
          (r'^(\d+)\s*(åˆ†å¾Œ|mins?|minutes?)$',lambda m:now+timedelta(minutes=int(m.group(1)))) ]
    for pat,fn in pats:
        mm=re.match(pat,t)
        if mm: dt=fn(mm); return dt.replace(hour=hour,minute=minute,second=0,microsecond=0)
    wk={'æœˆ':0,'ç«':1,'æ°´':2,'æœ¨':3,'é‡‘':4,'åœŸ':5,'æ—¥':6,'monday':0,'tuesday':1,'wednesday':2,'thursday':3,'friday':4,'saturday':5,'sunday':6,'mon':0,'tue':1,'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
    for name,num in wk.items():
        if name in t:
            d=num-now.weekday(); d+=7 if d<=0 else 0
            return (now+timedelta(days=d)).replace(hour=hour,minute=minute,second=0,microsecond=0)
    abs_p=[r'^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$',r'^(\d{1,2})[/-](\d{1,2})$',r'^(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥$',r'^(\d{1,2})æœˆ(\d{1,2})æ—¥$']
    for pat in abs_p:
        mm=re.match(pat,t)
        if mm:
            g=mm.groups()
            if len(g)==3 and len(g[0])==4: y,mo,d=int(g[0]),int(g[1]),int(g[2])
            elif len(g)==3: mo,d,y=int(g[0]),int(g[1]),now.year
            else: mo,d,y=int(g[0]),int(g[1]),now.year
            try: return datetime(y,mo,d,hour,minute)
            except ValueError: return None
    return None

STATUS_COLORS={'pending':discord.Color.red(),'accepted':discord.Color.gold(),'completed':discord.Color.green(),'declined':discord.Color.dark_gray(),'abandoned':discord.Color.dark_red()}
STATUS_EMOJI={'pending':'ğŸŸ¥','accepted':'ğŸŸ¨','completed':'ğŸŸ©','declined':'âšª','abandoned':'ğŸŸ«'}
STATUS_NAME={'pending':'Pending','accepted':'In Progress','completed':'Completed','declined':'Declined','abandoned':'Problem'}

def build_embed(trow,status:Optional[str]=None)->discord.Embed:
    st=status or trow[6]
    try: due_ts=int(datetime.fromisoformat(str(trow[5])).timestamp())
    except Exception: due_ts=int(datetime.strptime(str(trow[5]),"%Y-%m-%d %H:%M:%S").timestamp())
    emb=discord.Embed(title=f"ğŸ“‹ {trow[4]}", color=STATUS_COLORS.get(st, discord.Color.blurple()))
    emb.add_field(name="Due Date", value=f"<t:{due_ts}:F>", inline=True)
    emb.add_field(name="Status", value=f"{STATUS_EMOJI.get(st,'âšª')} {STATUS_NAME.get(st,st)}", inline=True)
    emb.add_field(name="Updated", value=f"<t:{int(datetime.now().timestamp())}:R>", inline=True)
    emb.set_footer(text=f"Task ID: {trow[0]}"); return emb

class TaskView(discord.ui.View):
    def __init__(self, tid:int, aid:int, iid:int, status:str):
        super().__init__(timeout=None); self.tid, self.aid, self.iid, self.status=tid,aid,iid,status; self._setup()
    def _setup(self):
        self.clear_items()
        if self.status=='pending': self.add_item(AcceptButton(self.tid)); self.add_item(DeclineButton(self.tid))
        elif self.status=='accepted': self.add_item(CompleteButton(self.tid)); self.add_item(AbandonButton(self.tid))
        elif self.status=='completed': self.add_item(UndoButton(self.tid))

class _BaseBtn(discord.ui.Button):
    def __init__(self,label,style,cid): super().__init__(label=label, style=style, custom_id=cid)
    async def _handle(self,it:discord.Interaction,new_status:str):
        t=db_exec("SELECT * FROM tasks WHERE id=?", (int(self.custom_id.split('_')[-1]),), fetch=True)
        if not t: await it.response.send_message("âŒ Task not found.", ephemeral=True); return
        t=t[0]
        if it.user.id!=t[3]: await it.response.send_message("âŒ You are not the assignee.", ephemeral=True); return
        db_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status,t[0]))
        t2=db_exec("SELECT * FROM tasks WHERE id=?", (t[0],), fetch=True)[0]
        await it.response.edit_message(embed=build_embed(t2,new_status), view=TaskView(t2[0],t2[3],t2[2],new_status))

class AcceptButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âœ… Accept", discord.ButtonStyle.success, f"accept_task_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')
class DeclineButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âŒ Decline", discord.ButtonStyle.danger, f"decline_task_{tid}")
    async def callback(self,it): await self._handle(it,'declined')
class CompleteButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("ğŸ“ Complete", discord.ButtonStyle.success, f"complete_task_{tid}")
    async def callback(self,it): await self._handle(it,'completed')
class AbandonButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âš ï¸ Problem", discord.ButtonStyle.danger, f"abandon_task_{tid}")
    async def callback(self,it): await self._handle(it,'abandoned')
class UndoButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("â†©ï¸ Undo", discord.ButtonStyle.secondary, f"undo_completion_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')

@bot.event
async def on_ready():
    logger.info(f"{bot.user} logged in. Guilds={len(bot.guilds)}"); init_db()
    try: logger.info("Text commands: %s", ", ".join(sorted(c.name for c in bot.commands)))
    except Exception: pass
    try:
        for g in bot.guilds: await bot.tree.sync(guild=g)
        logger.info("Slash commands synced.")
    except Exception as e: logger.error(f"Slash sync error: {e}")

@bot.event
async def on_message(message:discord.Message):
    if message.author.bot: return
    text=message.content.strip()
    if re.match(rf"^(?:<@!?{bot.user.id}>\s*)?[/!ï¼]?\s*setup\b", text, flags=re.I):
        ctx=await bot.get_context(message); await setup_cmd(ctx); return
    await bot.process_commands(message)

@bot.command(name="setup", aliases=["init","ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"])
async def setup_cmd(ctx:commands.Context):
    if not ctx.guild: await ctx.reply("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„"); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (ctx.author.id, ctx.guild.id))
    await ctx.reply("âœ… Setup complete. Use `!channels` â†’ `!test`")

@bot.command(name="channels")
async def channels_cmd(ctx:commands.Context):
    if not ctx.guild: return
    if not is_admin(ctx.author.id, ctx.guild.id): await ctx.reply("âŒ Admin only"); return
    created=[]
    mg=await ensure_mgmt(ctx.guild); 
    if mg: created.append(mg.name)
    cnt=0
    for m in ctx.guild.members:
        if m.bot: continue
        if cnt>=10: break
        ch=await ensure_personal(ctx.guild, m)
        if ch: created.append(ch.name); cnt+=1
        await asyncio.sleep(0.3)
    await ctx.reply("âœ… Channels: " + (", ".join(created) if created else "(none)"))

@bot.command(name="test")
async def test_cmd(ctx:commands.Context):
    if not ctx.guild: return
    due=datetime.now()+timedelta(hours=1, minutes=5)
    tid=insert_task(ctx.guild.id, ctx.author.id, ctx.author.id, "Test Task / ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due)
    task=get_task(tid); ch=await ensure_personal(ctx.guild, ctx.author)
    view=TaskView(tid, ctx.author.id, ctx.author.id, 'pending')
    if ch: await ch.send(ctx.author.mention, embed=build_embed(task), view=view)
    else:
        try: await ctx.author.send(embed=build_embed(task), view=view)
        except: pass
    await ctx.reply(f"âœ… Test created (ID={tid})")

@bot.command(name="ping")
async def ping_cmd(ctx:commands.Context): await ctx.reply("pong")

@bot.tree.command(name="setup", description="Initial setup / åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—")
async def setup_slash(it:discord.Interaction):
    if not it.guild_id: await it.response.send_message("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„", ephemeral=True); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (it.user.id, it.guild_id))
    await it.response.send_message("âœ… Setup complete. Run `/channels` or `!channels` next.", ephemeral=True)

@bot.tree.command(name="channels", description="Create task channels")
async def channels_slash(it:discord.Interaction):
    if not it.guild: await it.response.send_message("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„", ephemeral=True); return
    if not is_admin(it.user.id, it.guild.id): await it.response.send_message("âŒ Admin only", ephemeral=True); return
    await it.response.send_message("âœ… OK (use `!channels` too)", ephemeral=True)

@tasks.loop(minutes=5)
async def check_reminders():
    now=datetime.now(); soon=now+timedelta(hours=1)
    rows=db_exec("SELECT id,guild_id,assignee_id,task_name,due_date FROM tasks WHERE status='accepted' AND reminder_sent=0 AND due_date>? AND due_date<=?", (now,soon), fetch=True)
    for tid,gid,aid,tname,due in rows:
        guild=bot.get_guild(gid); 
        if not guild: continue
        user=guild.get_member(aid)
        if not user: continue
        try:
            try: due_ts=int(datetime.fromisoformat(str(due)).timestamp())
            except Exception: due_ts=int(datetime.strptime(str(due), "%Y-%m-%d %H:%M:%S").timestamp())
            emb=discord.Embed(title="â° Task Reminder", description=f"**{tname}**\nDue in less than 1 hour!", color=discord.Color.orange())
            emb.add_field(name="Due", value=f"<t:{due_ts}:F>", inline=True)
            try: await user.send(embed=emb)
            except Exception:
                ch=await ensure_personal(guild,user)
                if ch: await ch.send(user.mention, embed=emb)
            db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))
        except Exception as e:
            logging.error(f"reminder failed: {e}"); db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))

@check_reminders.before_loop
async def _b1(): await bot.wait_until_ready()
@tasks.loop(minutes=1)
async def heartbeat_check():
    try:
        if heartbeat_check.current_loop % 5 == 0:
            logger.info(f"Heartbeat OK. Guilds={len(bot.guilds)} Latency={round(bot.latency*1000)}ms")
    except Exception as e: logger.error(f"Heartbeat error: {e}")
@heartbeat_check.before_loop
async def _b2(): await bot.wait_until_ready()
@tasks.loop(hours=1)
async def cleanup_memory():
    try:
        if hasattr(bot,"_connection") and hasattr(bot._connection,"_messages"): bot._connection._messages.clear()
        logger.info("Memory cleanup done.")
    except Exception as e: logger.error(f"cleanup error: {e}")
@cleanup_memory.before_loop
async def _b3(): await bot.wait_until_ready()

@bot.event
async def on_command_error(ctx:commands.Context, error:Exception):
    if isinstance(error, commands.CommandNotFound):
        text=ctx.message.content.strip()
        if re.match(r"^[/!ï¼]?\s*setup\b", text, flags=re.I):
            await setup_cmd(ctx); return
        return
    logging.error(f"Command error: {error}", exc_info=True)
    try: await ctx.reply("âŒ An error occurred.")
    except: pass

if __name__ == "__main__":
    token=os.getenv("DISCORD_BOT_TOKEN")
    if not token:
        raise SystemExit("DISCORD_BOT_TOKEN ãŒæœªè¨­å®šã§ã™ã€‚export DISCORD_BOT_TOKEN=... ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚")
    bot.run(token)
