# -*- coding: utf-8 -*-
# mybot.py (failsafe setup edition)
import os, re, json, sqlite3, logging, asyncio
from datetime import datetime, timedelta
from typing import Optional, List

import discord
from discord import app_commands
from discord.ext import commands, tasks

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)-8s %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("bot.log", encoding="utf-8")]
)
logger = logging.getLogger("taskbot")

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.message_content = True

bot = commands.Bot(
    command_prefix=commands.when_mentioned_or("!", "！", "/"),
    intents=intents,
    case_insensitive=True,
    help_command=None,
    max_messages=100,
)

DB_PATH = "reminder_bot.db"
def db_exec(q: str, params: tuple = (), fetch=False):
    conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
    cur.execute(q, params); rows = cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

def init_db():
    db_exec("""CREATE TABLE IF NOT EXISTS admins(user_id INTEGER, guild_id INTEGER, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS instructors(user_id INTEGER, guild_id INTEGER, target_users TEXT, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS tasks(
        id INTEGER PRIMARY KEY AUTOINCREMENT, guild_id INTEGER, instructor_id INTEGER, assignee_id INTEGER,
        task_name TEXT, due_date TIMESTAMP, status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        message_id INTEGER, channel_id INTEGER, reminder_sent INTEGER DEFAULT 0)""")
    cols = db_exec("PRAGMA table_info(tasks)", fetch=True)
    if "reminder_sent" not in [c[1] for c in cols]:
        db_exec("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")

def is_admin(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM admins WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))
def is_instructor(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM instructors WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))

def insert_task(gid:int,iid:int,aid:int,name:str,due:datetime)->int:
    db_exec("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date) VALUES (?,?,?,?,?)", (gid,iid,aid,name,due))
    return db_exec("SELECT last_insert_rowid()", fetch=True)[0][0]

def get_task(tid:int):
    r=db_exec("SELECT * FROM tasks WHERE id=?", (tid,), fetch=True)
    return r[0] if r else None

async def ensure_mgmt(guild:discord.Guild)->Optional[discord.TextChannel]:
    for name in ("task-management","タスク管理"):
        ch = discord.utils.get(guild.channels, name=name)
        if isinstance(ch, discord.TextChannel): return ch
    try:
        return await guild.create_text_channel("task-management", overwrites={guild.default_role: discord.PermissionOverwrite(read_messages=False)})
    except Exception as e:
        logger.error(f"mgmt create failed: {e}"); return None

async def ensure_personal(guild:discord.Guild,user:discord.Member)->Optional[discord.TextChannel]:
    name=f"to-{user.display_name}".lower().replace(" ","-")
    ch=discord.utils.get(guild.channels,name=name)
    if isinstance(ch,discord.TextChannel): return ch
    try:
        ow={guild.default_role: discord.PermissionOverwrite(read_messages=False), user: discord.PermissionOverwrite(read_messages=True, send_messages=True)}
        return await guild.create_text_channel(name=name, overwrites=ow, topic=f"{user.display_name} の個人タスク")
    except Exception as e:
        logger.error(f"personal create failed: {e}"); return None

def parse_date(s:str)->Optional[datetime]:
    now=datetime.now(); t=s.strip().lower()
    m=re.search(r'(\d{1,2}):(\d{2})$',t)
    if m: hour,minute=int(m.group(1)),int(m.group(2)); t=t[:m.start()].strip()
    else: hour,minute=23,59
    pats=[(r'^(今日|today)$',lambda m:now),(r'^(明日|tomorrow)$',lambda m:now+timedelta(days=1)),
          (r'^(明後日|day after tomorrow)$',lambda m:now+timedelta(days=2)),(r'^(昨日|yesterday)$',lambda m:now-timedelta(days=1)),
          (r'^(\d+)\s*(日後|days?)$',lambda m:now+timedelta(days=int(m.group(1)))),
          (r'^(\d+)\s*(週間後|weeks?)$',lambda m:now+timedelta(weeks=int(m.group(1)))),
          (r'^(\d+)\s*(時間後|hours?)$',lambda m:now+timedelta(hours=int(m.group(1)))),
          (r'^(\d+)\s*(分後|mins?|minutes?)$',lambda m:now+timedelta(minutes=int(m.group(1)))) ]
    for pat,fn in pats:
        mm=re.match(pat,t)
        if mm: dt=fn(mm); return dt.replace(hour=hour,minute=minute,second=0,microsecond=0)
    wk={'月':0,'火':1,'水':2,'木':3,'金':4,'土':5,'日':6,'monday':0,'tuesday':1,'wednesday':2,'thursday':3,'friday':4,'saturday':5,'sunday':6,'mon':0,'tue':1,'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
    for name,num in wk.items():
        if name in t:
            d=num-now.weekday(); d+=7 if d<=0 else 0
            return (now+timedelta(days=d)).replace(hour=hour,minute=minute,second=0,microsecond=0)
    abs_p=[r'^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$',r'^(\d{1,2})[/-](\d{1,2})$',r'^(\d{4})年(\d{1,2})月(\d{1,2})日$',r'^(\d{1,2})月(\d{1,2})日$']
    for pat in abs_p:
        mm=re.match(pat,t)
        if mm:
            g=mm.groups()
            if len(g)==3 and len(g[0])==4: y,mo,d=int(g[0]),int(g[1]),int(g[2])
            elif len(g)==3: mo,d,y=int(g[0]),int(g[1]),now.year
            else: mo,d,y=int(g[0]),int(g[1]),now.year
            try: return datetime(y,mo,d,hour,minute)
            except ValueError: return None
    return None

STATUS_COLORS={'pending':discord.Color.red(),'accepted':discord.Color.gold(),'completed':discord.Color.green(),'declined':discord.Color.dark_gray(),'abandoned':discord.Color.dark_red()}
STATUS_EMOJI={'pending':'🟥','accepted':'🟨','completed':'🟩','declined':'⚪','abandoned':'🟫'}
STATUS_NAME={'pending':'Pending','accepted':'In Progress','completed':'Completed','declined':'Declined','abandoned':'Problem'}

def build_embed(trow,status:Optional[str]=None)->discord.Embed:
    st=status or trow[6]
    try: due_ts=int(datetime.fromisoformat(str(trow[5])).timestamp())
    except Exception: due_ts=int(datetime.strptime(str(trow[5]),"%Y-%m-%d %H:%M:%S").timestamp())
    emb=discord.Embed(title=f"📋 {trow[4]}", color=STATUS_COLORS.get(st, discord.Color.blurple()))
    emb.add_field(name="Due Date", value=f"<t:{due_ts}:F>", inline=True)
    emb.add_field(name="Status", value=f"{STATUS_EMOJI.get(st,'⚪')} {STATUS_NAME.get(st,st)}", inline=True)
    emb.add_field(name="Updated", value=f"<t:{int(datetime.now().timestamp())}:R>", inline=True)
    emb.set_footer(text=f"Task ID: {trow[0]}"); return emb

class TaskView(discord.ui.View):
    def __init__(self, tid:int, aid:int, iid:int, status:str):
        super().__init__(timeout=None); self.tid, self.aid, self.iid, self.status=tid,aid,iid,status; self._setup()
    def _setup(self):
        self.clear_items()
        if self.status=='pending': self.add_item(AcceptButton(self.tid)); self.add_item(DeclineButton(self.tid))
        elif self.status=='accepted': self.add_item(CompleteButton(self.tid)); self.add_item(AbandonButton(self.tid))
        elif self.status=='completed': self.add_item(UndoButton(self.tid))

class _BaseBtn(discord.ui.Button):
    def __init__(self,label,style,cid): super().__init__(label=label, style=style, custom_id=cid)
    async def _handle(self,it:discord.Interaction,new_status:str):
        t=db_exec("SELECT * FROM tasks WHERE id=?", (int(self.custom_id.split('_')[-1]),), fetch=True)
        if not t: await it.response.send_message("❌ Task not found.", ephemeral=True); return
        t=t[0]
        if it.user.id!=t[3]: await it.response.send_message("❌ You are not the assignee.", ephemeral=True); return
        db_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status,t[0]))
        t2=db_exec("SELECT * FROM tasks WHERE id=?", (t[0],), fetch=True)[0]
        await it.response.edit_message(embed=build_embed(t2,new_status), view=TaskView(t2[0],t2[3],t2[2],new_status))

class AcceptButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("✅ Accept", discord.ButtonStyle.success, f"accept_task_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')
class DeclineButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("❌ Decline", discord.ButtonStyle.danger, f"decline_task_{tid}")
    async def callback(self,it): await self._handle(it,'declined')
class CompleteButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("📝 Complete", discord.ButtonStyle.success, f"complete_task_{tid}")
    async def callback(self,it): await self._handle(it,'completed')
class AbandonButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("⚠️ Problem", discord.ButtonStyle.danger, f"abandon_task_{tid}")
    async def callback(self,it): await self._handle(it,'abandoned')
class UndoButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("↩️ Undo", discord.ButtonStyle.secondary, f"undo_completion_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')

@bot.event
async def on_ready():
    logger.info(f"{bot.user} logged in. Guilds={len(bot.guilds)}"); init_db()
    try: logger.info("Text commands: %s", ", ".join(sorted(c.name for c in bot.commands)))
    except Exception: pass
    try:
        for g in bot.guilds: await bot.tree.sync(guild=g)
        logger.info("Slash commands synced.")
    except Exception as e: logger.error(f"Slash sync error: {e}")

@bot.event
async def on_message(message:discord.Message):
    if message.author.bot: return
    text=message.content.strip()
    if re.match(rf"^(?:<@!?{bot.user.id}>\s*)?[/!！]?\s*setup\b", text, flags=re.I):
        ctx=await bot.get_context(message); await setup_cmd(ctx); return
    await bot.process_commands(message)

@bot.command(name="setup", aliases=["init","セットアップ"])
async def setup_cmd(ctx:commands.Context):
    if not ctx.guild: await ctx.reply("❌ サーバー内で実行してください"); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (ctx.author.id, ctx.guild.id))
    await ctx.reply("✅ Setup complete. Use `!channels` → `!test`")

@bot.command(name="channels")
async def channels_cmd(ctx:commands.Context):
    if not ctx.guild: return
    if not is_admin(ctx.author.id, ctx.guild.id): await ctx.reply("❌ Admin only"); return
    created=[]
    mg=await ensure_mgmt(ctx.guild); 
    if mg: created.append(mg.name)
    cnt=0
    for m in ctx.guild.members:
        if m.bot: continue
        if cnt>=10: break
        ch=await ensure_personal(ctx.guild, m)
        if ch: created.append(ch.name); cnt+=1
        await asyncio.sleep(0.3)
    await ctx.reply("✅ Channels: " + (", ".join(created) if created else "(none)"))

@bot.command(name="test")
async def test_cmd(ctx:commands.Context):
    if not ctx.guild: return
    due=datetime.now()+timedelta(hours=1, minutes=5)
    tid=insert_task(ctx.guild.id, ctx.author.id, ctx.author.id, "Test Task / テストタスク", due)
    task=get_task(tid); ch=await ensure_personal(ctx.guild, ctx.author)
    view=TaskView(tid, ctx.author.id, ctx.author.id, 'pending')
    if ch: await ch.send(ctx.author.mention, embed=build_embed(task), view=view)
    else:
        try: await ctx.author.send(embed=build_embed(task), view=view)
        except: pass
    await ctx.reply(f"✅ Test created (ID={tid})")

@bot.command(name="ping")
async def ping_cmd(ctx:commands.Context): await ctx.reply("pong")

@bot.tree.command(name="setup", description="Initial setup / 初期セットアップ")
async def setup_slash(it:discord.Interaction):
    if not it.guild_id: await it.response.send_message("❌ サーバー内で実行してください", ephemeral=True); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (it.user.id, it.guild_id))
    await it.response.send_message("✅ Setup complete. Run `/channels` or `!channels` next.", ephemeral=True)

@bot.tree.command(name="channels", description="Create task channels")
async def channels_slash(it:discord.Interaction):
    if not it.guild: await it.response.send_message("❌ サーバー内で実行してください", ephemeral=True); return
    if not is_admin(it.user.id, it.guild.id): await it.response.send_message("❌ Admin only", ephemeral=True); return
    await it.response.send_message("✅ OK (use `!channels` too)", ephemeral=True)

@tasks.loop(minutes=5)
async def check_reminders():
    now=datetime.now(); soon=now+timedelta(hours=1)
    rows=db_exec("SELECT id,guild_id,assignee_id,task_name,due_date FROM tasks WHERE status='accepted' AND reminder_sent=0 AND due_date>? AND due_date<=?", (now,soon), fetch=True)
    for tid,gid,aid,tname,due in rows:
        guild=bot.get_guild(gid); 
        if not guild: continue
        user=guild.get_member(aid)
        if not user: continue
        try:
            try: due_ts=int(datetime.fromisoformat(str(due)).timestamp())
            except Exception: due_ts=int(datetime.strptime(str(due), "%Y-%m-%d %H:%M:%S").timestamp())
            emb=discord.Embed(title="⏰ Task Reminder", description=f"**{tname}**\nDue in less than 1 hour!", color=discord.Color.orange())
            emb.add_field(name="Due", value=f"<t:{due_ts}:F>", inline=True)
            try: await user.send(embed=emb)
            except Exception:
                ch=await ensure_personal(guild,user)
                if ch: await ch.send(user.mention, embed=emb)
            db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))
        except Exception as e:
            logging.error(f"reminder failed: {e}"); db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))

@check_reminders.before_loop
async def _b1(): await bot.wait_until_ready()
@tasks.loop(minutes=1)
async def heartbeat_check():
    try:
        if heartbeat_check.current_loop % 5 == 0:
            logger.info(f"Heartbeat OK. Guilds={len(bot.guilds)} Latency={round(bot.latency*1000)}ms")
    except Exception as e: logger.error(f"Heartbeat error: {e}")
@heartbeat_check.before_loop
async def _b2(): await bot.wait_until_ready()
@tasks.loop(hours=1)
async def cleanup_memory():
    try:
        if hasattr(bot,"_connection") and hasattr(bot._connection,"_messages"): bot._connection._messages.clear()
        logger.info("Memory cleanup done.")
    except Exception as e: logger.error(f"cleanup error: {e}")
@cleanup_memory.before_loop
async def _b3(): await bot.wait_until_ready()

@bot.event
async def on_command_error(ctx:commands.Context, error:Exception):
    if isinstance(error, commands.CommandNotFound):
        text=ctx.message.content.strip()
        if re.match(r"^[/!！]?\s*setup\b", text, flags=re.I):
            await setup_cmd(ctx); return
        return
    logging.error(f"Command error: {error}", exc_info=True)
    try: await ctx.reply("❌ An error occurred.")
    except: pass

# ==== HOTFIX (pre-run safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

def __fx_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    logger.info(f"[HOTFIX] add_task inserted id={tid}, assignee={assignee_id}, name={task_name}")
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fx_add_task)
except Exception:
    pass

async def __fx_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("[HOTFIX] task_id lookup failed (no row)"); return
            task_id = row[0][0]
        logger.info(f"[HOTFIX] send_task_notification start task_id={task_id}, assignee={assignee.id}")

        ch = _discord.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow = {guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                      assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch = await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
                intro = _discord.Embed(title="📋 個人タスクチャンネル",
                                       description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                                       color=_discord.Color.blue())
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"[HOTFIX] cannot create channel/DM: {e}")
                    return

        embed = _discord.Embed(title=f"📋 {task_name}",
                               description=f"**期日: {due_date.strftime('%Y/%m/%d %H:%M')}**",
                               color=_discord.Color.gold())
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            th = await msg.create_thread(name=f"🟥 {task_name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
            detail = _discord.Embed(title="📋 タスク詳細", color=_discord.Color.blue())
            detail.add_field(name="指示者", value=instructor.mention, inline=True)
            detail.add_field(name="状態", value="🟥 未受託", inline=True)
            detail.add_field(name="作成日時", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await th.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception as e:
            logger.warning(f"[HOTFIX] thread create failed: {e}")
    except Exception as e:
        logger.error(f"[HOTFIX] send_task_notification error: {e}", exc_info=True)

send_task_notification = __fx_send_task_notification

try:
    bot.remove_command('test'); bot.remove_command('テスト')
except Exception:
    pass

@bot.command(name='テスト', aliases=['test'])
async def __fx_test(ctx):
    try:
        logger.info("[HOTFIX] __fx_test invoked by %s in guild %s", ctx.author.id, ctx.guild.id)
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="テストタスク",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("❌ タスク作成に失敗しました。（直後確認NG）"); return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "テストタスク", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="🧪 テストタスク作成", description="タスク作成機能のテストが成功しました！", color=_discord.Color.green())
        ok.add_field(name="タスクID", value=str(task_id), inline=True)
        ok.add_field(name="期日", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[HOTFIX] __fx_test error: {e}", exc_info=True)
        await ctx.send("❌ テスト中にエラーが発生しました。")
# ==== /HOTFIX (pre-run) ====

# ==== FIX_BLOCK (pre-run, self-contained test & notify) ====
import sqlite3 as __sq, datetime as __dt, discord as __dd

def __fix_db_add_task(gid, iid, aid, name, due, mid, cid):
    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
    cur.execute("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) VALUES (?,?,?,?,?,?,?)",
                (gid, iid, aid, name, due, mid, cid))
    tid = cur.lastrowid
    conn.commit(); conn.close()
    return tid

async def __fix_notify_personal(guild, assignee, instructor, name, due, task_id):
    ch = __dd.utils.get(guild.channels, name=f"to-{assignee.display_name}")
    if not ch:
        try:
            ow = {guild.default_role: __dd.PermissionOverwrite(read_messages=False),
                  assignee: __dd.PermissionOverwrite(read_messages=True, send_messages=True)}
            ch = await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
            intro = __dd.Embed(title="📋 個人タスクチャンネル",
                               description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                               color=__dd.Color.blue())
            await ch.send(embed=intro)
        except Exception:
            try:
                ch = await assignee.create_dm()
            except:
                return

    emb = __dd.Embed(title=f"📋 {name}", description=f"**期日: {due.strftime('%Y/%m/%d %H:%M')}**", color=__dd.Color.gold())
    view = TaskView(task_id, assignee.id, instructor.id, "pending")
    msg = await ch.send(assignee.mention, embed=emb, view=view)
    try:
        th = await msg.create_thread(name=f"🟥 {name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
        d = __dd.Embed(title="📋 タスク詳細", color=__dd.Color.blue())
        d.add_field(name="指示者", value=instructor.mention, inline=True)
        d.add_field(name="状態", value="🟥 未受託", inline=True)
        d.add_field(name="作成日時", value=__dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
        await th.send(embed=d, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
    except Exception:
        pass

try:
    bot.remove_command('test'); bot.remove_command('テスト')
except Exception:
    pass

@bot.command(name='テスト', aliases=['test'])
async def __fix_test(ctx):
    try:
        due = __dt.datetime.now() + __dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        tid = __fix_db_add_task(ctx.guild.id, ctx.author.id, ctx.author.id, "テストタスク", due, ctx.message.id, ctx.channel.id)
        await __fix_notify_personal(ctx.guild, ctx.author, ctx.author, "テストタスク", due, tid)
        ok = __dd.Embed(title="🧪 テストタスク作成", description="タスク作成機能のテストが成功しました！", color=__dd.Color.green())
        ok.add_field(name="タスクID", value=str(tid), inline=True)
        ok.add_field(name="期日", value=due.strftime('%Y/%m/%d %H:%M'), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[FIX_BLOCK] test error: {e}", exc_info=True)
        await ctx.send("❌ テスト中にエラーが発生しました。")
# ==== /FIX_BLOCK ====

# ==== WRAP_BLOCK (pre-run handle_task_action wrapper) ====
import discord as __dd
logger.info("[wrap-load] handle_task_action wrapper installed")

__orig_handle_task_action = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    if callable(__orig_handle_task_action):
        await __orig_handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status)

    status_map = {
        "accept_task": "accepted",
        "decline_task": "declined",
        "complete_task": "completed",
        "abandon_task": "abandoned",
        "undo_completion": "accepted",
    }
    new_status = status_map.get(action)
    if not new_status:
        logger.info(f"[rename-wrap] unknown action: {action}")
        return

    try:
        thread = interaction.message.channel if isinstance(interaction.message.channel, __dd.Thread) else getattr(interaction.message, "thread", None)
        if not isinstance(thread, __dd.Thread):
            logger.info("[rename-wrap] skip: not a thread")
            return

        current = thread.name or ""
        status_emojis = {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}
        emoji = status_emojis.get(new_status, "⚪")

        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = emoji + current[len(e):]
                break
        else:
            new_name = f"{emoji} {current}"

        new_name = new_name.lstrip()
        if new_name != current:
            await thread.edit(name=new_name)
            logger.info(f"[rename-wrap] Thread name updated: '{current}' -> '{new_name}' ({new_status})")
        else:
            logger.info(f"[rename-wrap] no change: '{current}' ({new_status})")
    except Exception as e:
        logger.error(f"[rename-wrap] failed: {e}", exc_info=True)
# ==== /WRAP_BLOCK ====

# ==== RENAME_PRE (before run) ====
import asyncio as __aio, sqlite3 as __sq, re as __re, discord as __dd

def __emoji_for(status:str)->str:
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status,"⚪")

def __find_thread(msg: __dd.Message, task_name:str):
    # 優先: いまのメッセージがThread内 / 親メッセージにthreadが付いている
    th = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg,"thread",None)
    if isinstance(th, __dd.Thread):
        return th
    # 親チャンネルの active threads をタスク名で探索
    try:
        for t in getattr(msg.channel,"threads",[]):
            if task_name and (task_name in (t.name or "")):
                return t
    except Exception:
        pass
    return None

@bot.listen('on_interaction')
async def __rename_after_interaction(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        data = interaction.data or {}
        cid  = data.get('custom_id') or ''
        m = __re.search(r'_(\d+)$', cid)
        if not m:
            return
        task_id = int(m.group(1))

        # 元の処理が終わるのを少し待つ
        await __aio.sleep(0.35)

        # DBから最新 status を取得
        try:
            c = __sq.connect('reminder_bot.db').cursor()
            c.execute("SELECT task_name,status FROM tasks WHERE id=?", (task_id,))
            row = c.fetchone()
            c.connection.close()
        except Exception as e:
            logger.error(f"[rename-pre] DB error: {e}", exc_info=True); return
        if not row:
            logger.info("[rename-pre] task not found"); return
        task_name, status = row[0], row[1]

        # 対象スレッドを特定
        msg = interaction.message
        th  = __find_thread(msg, task_name)
        if not isinstance(th, __dd.Thread):
            logger.info("[rename-pre] skip: no thread"); return

        # 権限チェック
        me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
        if me:
            p = th.permissions_for(me)
            if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                logger.info("[rename-pre] skip: no permission"); return

        # 先頭絵文字を差し替え
        cur = th.name or ""
        em  = __emoji_for(status)
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if cur.startswith(e):
                new = em + cur[len(e):]
                break
        else:
            new = f"{em} {cur}"
        new = new.lstrip()

        if new != cur:
            await th.edit(name=new)
            logger.info(f"[rename-pre] updated: '{cur}' -> '{new}' (status={status}, id={task_id})")
        else:
            logger.info(f"[rename-pre] no change: '{cur}' (status={status})")
    except Exception as e:
        logger.error(f"[rename-pre] failed: {e}", exc_info=True)
# ==== /RENAME_PRE ====

# ==== FINAL_PATCH (pre-run) ====
import sqlite3 as __sq, datetime as __dt, asyncio as __aio, discord as __dd, re as __re

# --- DB helpers & migration ---
def __db_exec(sql, params=(), fetch=False):
    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
    cur.execute(sql, params)
    rows = cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

# tasks.thread_id 追加（無ければ）
try:
    cols = {c[1] for c in __db_exec("PRAGMA table_info(tasks)", fetch=True)}
    if 'thread_id' not in cols:
        __db_exec("ALTER TABLE tasks ADD COLUMN thread_id INTEGER")
        logger.info("[final] added tasks.thread_id")
except Exception as e:
    logger.error(f"[final] migration error: {e}", exc_info=True)

# --- 絵文字マップ ---
def __emoji_for(status:str)->str:
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status, "⚪")

# --- send_task_notification を上書き（thread_id を保存・ID非表示） ---
async def __final_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        # task_id が渡されない場合の保険
        if task_id is None:
            row = __db_exec(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name), fetch=True)
            if not row: 
                logger.error("[final] task lookup failed"); return
            task_id = row[0][0]

        # 個人チャンネル
        ch = __dd.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow = {guild.default_role: __dd.PermissionOverwrite(read_messages=False),
                      assignee: __dd.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch = await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
                intro = __dd.Embed(title="📋 個人タスクチャンネル",
                                   description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                                   color=__dd.Color.blue())
                await ch.send(embed=intro)
            except Exception:
                try: ch = await assignee.create_dm()
                except: return

        # メインEmbed（※タスクIDは出さない）
        emb = __dd.Embed(title=f"📋 {task_name}",
                         description=f"**期日: {due_date.strftime('%Y/%m/%d %H:%M')}**",
                         color=__dd.Color.gold())
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=emb, view=view)

        # 詳細スレッド作成
        th = await msg.create_thread(name=f"🟥 {task_name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
        detail = __dd.Embed(title="📋 タスク詳細", color=__dd.Color.blue())
        detail.add_field(name="指示者", value=instructor.mention, inline=True)
        detail.add_field(name="状態", value="🟥 未受託", inline=True)
        detail.add_field(name="作成日時", value=__dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
        await th.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))

        # thread_id を保存
        __db_exec("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        logger.info(f"[final] saved thread_id={th.id} for task={task_id}")
    except Exception as e:
        logger.error(f"[final] send_task_notification error: {e}", exc_info=True)

send_task_notification = __final_send_task_notification

# --- 既存の送信系からのタスクID表示を抑止：指示者通知の上書き（ID非表示） ---
async def __final_notify_instructor(guild, instructor, message, assignee_id, task_id):
    try:
        emb = __dd.Embed(title=message, color=__dd.Color.blue())
        emb.add_field(name="担当者", value=f"<@{assignee_id}>", inline=True)
        await instructor.send(embed=emb)
    except __dd.Forbidden:
        pass
    except Exception as e:
        logger.error(f"[final] notify DM error: {e}", exc_info=True)

# あれば差し替え
if 'send_notification_to_instructor' in globals():
    globals()['send_notification_to_instructor'] = __final_notify_instructor

# --- インタラクション後に、thread_id を使って確実にリネーム ---
@bot.listen('on_interaction')
async def __final_rename_listener(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        data = interaction.data or {}
        cid  = data.get('custom_id') or ''
        m = __re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m:
            return
        action, tid = m.group(1), int(m.group(2))
        desired = {"accept_task":"accepted","decline_task":"declined","complete_task":"completed",
                   "abandon_task":"abandoned","undo_completion":"accepted"}[action]

        # 元処理の完了を少し待つ＋短いリトライ
        for i in range(5):
            await __aio.sleep(0.20 if i else 0.40)
            row = __db_exec("SELECT thread_id,status,task_name FROM tasks WHERE id=?", (tid,), fetch=True)
            if not row:
                logger.info("[final-rename] no task row"); return
            thread_id, status, name = row[0]
            target_status = desired if action=="undo_completion" else status
            if not thread_id:
                continue  # 次の試行へ

            th = interaction.client.get_channel(thread_id)
            if not isinstance(th, __dd.Thread):
                try: th = await interaction.client.fetch_channel(thread_id)
                except Exception: th = None
            if not isinstance(th, __dd.Thread):
                continue

            # 権限
            me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
            if me:
                p = th.permissions_for(me)
                if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                    logger.info("[final-rename] no permission"); return

            cur = th.name or ""
            em  = __emoji_for(target_status)
            for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
                if cur.startswith(e):
                    new = em + cur[len(e):]; break
            else:
                new = f"{em} {cur}"
            new = new.lstrip()

            if new != cur:
                await th.edit(name=new)
                logger.info(f"[final-rename] updated: '{cur}' -> '{new}' (status={target_status}, id={tid})")
            else:
                logger.info(f"[final-rename] no change: '{cur}' (status={target_status}, id={tid})")
            return

        logger.info(f"[final-rename] giving up (id={tid})")
    except Exception as e:
        logger.error(f"[final-rename] failed: {e}", exc_info=True)

# --- リアクション通知（担当者が反応したら指示者へDM） ---
@bot.listen('on_raw_reaction_add')
async def __final_react_notify(payload: __dd.RawReactionActionEvent):
    try:
        if payload.guild_id is None or payload.user_id == (bot.user.id if bot.user else 0):
            return
        # メッセージIDからタスクを引く
        row = __db_exec("SELECT instructor_id,assignee_id,task_name FROM tasks WHERE message_id=? LIMIT 1",
                        (payload.message_id,), fetch=True)
        if not row:
            return
        instructor_id, assignee_id, task_name = row[0]
        if payload.user_id != assignee_id:
            return  # 担当者以外のリアクションは無視

        guild = bot.get_guild(payload.guild_id)
        if not guild:
            return
        instructor = guild.get_member(instructor_id)
        assignee   = guild.get_member(assignee_id)
        if not instructor or not assignee:
            return

        emoji = str(payload.emoji)
        emb = __dd.Embed(title="📣 リアクション通知", description=f"{assignee.mention} が **{task_name}** に {emoji} で反応しました。", color=__dd.Color.blurple())
        try:
            await instructor.send(embed=emb)
        except __dd.Forbidden:
            pass
        except Exception as e:
            logger.error(f"[final-react] DM error: {e}", exc_info=True)
    except Exception as e:
        logger.error(f"[final-react] failed: {e}", exc_info=True)
# ==== /FINAL_PATCH ====

# ==== STATE_COLOR_PATCH (pre-run) ====
import sqlite3 as __sq, asyncio as __aio, discord as __dd, re as __re, datetime as __dt

def __sc_emoji(st): return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(st,"⚪")
def __sc_desired(action): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted","abandon_task":"abandoned","decline_task":"declined"}.get(action)

# EmbedからTask ID表記を排除し、必要項目だけで再構築
def __sc_sanitize_embed(old: __dd.Embed, title:str, due_str:str, status_str:str, color:__dd.Color)->__dd.Embed:
    e = __dd.Embed(title=title, description=f"**期日: {due_str}**", color=color)
    # もし旧Embedに別の情報があれば必要に応じてここに追加する
    return e

# on_interaction 後に：thread_id を使って確実に色更新＋Embed整理
@bot.listen('on_interaction')
async def __state_color_listener(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component: return
        cid=(interaction.data or {}).get('custom_id') or ''
        m=__re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m: return
        action, tid = m.group(1), int(m.group(2))
        desired = __sc_desired(action)
        if not desired: return

        # 反映競合回避のため少し待つ
        await __aio.sleep(0.35)

        # DBから thread_id / due_date / task_name を取得（thread_idが無ければ後で補完）
        try:
            conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("SELECT thread_id,due_date,task_name FROM tasks WHERE id=?", (tid,))
            row=cur.fetchone(); conn.close()
        except Exception as e:
            logger.error(f"[sc] DB error: {e}", exc_info=True); return
        if not row: 
            logger.info("[sc] task row not found"); return

        thread_id, due, task_name = row[0], row[1], row[2]

        # スレッド特定（thread_id優先→文脈から補完＆保存）
        th=None
        if thread_id:
            th = interaction.client.get_channel(thread_id)
            if not isinstance(th, __dd.Thread):
                try: th = await interaction.client.fetch_channel(thread_id)
                except Exception: th=None
        if not isinstance(th, __dd.Thread):
            msg=interaction.message
            th = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg,"thread",None)
            if not isinstance(th, __dd.Thread):
                try:
                    for t in getattr(msg.channel,"threads",[]):
                        if task_name and task_name in (t.name or ""):
                            th=t; break
                except Exception: pass
            if isinstance(th, __dd.Thread):
                try:
                    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
                    cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, tid))
                    conn.commit(); conn.close()
                except Exception: pass

        if not isinstance(th, __dd.Thread):
            logger.info("[sc] skip: no thread"); return

        # 権限
        me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
        if me:
            p = th.permissions_for(me)
            if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                logger.info("[sc] skip: no permission"); return

        # 先頭絵文字を「アクション由来」の desired で確実に更新
        cur_name = th.name or ""
        em = __sc_emoji(desired)
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if cur_name.startswith(e):
                new = em + cur_name[len(e):]; break
        else:
            new = f"{em} {cur_name}"
        new = new.lstrip()

        if new != cur_name:
            await th.edit(name=new)
            logger.info(f"[sc] renamed: '{cur_name}' -> '{new}' (action={action}, id={tid})")
        else:
            logger.info(f"[sc] no change: '{cur_name}' (action={action})")

        # 表示Embedも Task ID を消して再編集（メイン通知メッセージ）
        try:
            # dueの文字列化
            try:
                # SQLiteは文字列で出るのでそのまま表示
                due_str = str(due)
            except Exception:
                due_str = __dt.datetime.now().strftime("%Y/%m/%d %H:%M")
            color = __dd.Color.gold() if desired=="pending" else (__dd.Color.yellow() if desired=="accepted" else __dd.Color.green())
            title = interaction.message.embeds[0].title if interaction.message.embeds else f"📋 {task_name}"
            clean = __sc_sanitize_embed(interaction.message.embeds[0] if interaction.message.embeds else None,
                                        title, due_str, desired, color)
            await interaction.message.edit(embed=clean)
        except Exception as e:
            # ここで失敗しても致命ではない（リネームは済）
            logger.debug(f"[sc] sanitize embed skipped: {e}")
    except Exception as e:
        logger.error(f"[sc] failed: {e}", exc_info=True)
# ==== /STATE_COLOR_PATCH ====

# ==== THREAD_NAME_ID (add #id to thread names) ====
import re as __re, sqlite3 as __sq, discord as __dd

def __tn_format(task_name:str, emoji:str, tid:int)->str:
    base = f"{emoji} {task_name} - 詳細"
    # 既に #id が付いていれば重複回避
    return base if __re.search(r"#\d+$", base) else f"{base} #{tid}"

# 新規作成時（send_task_notification で thread 作成後に #id を付与する）が既に入っているはずだが、
# 念のため rename リスナー側でも #id を補正する
@bot.listen('on_interaction')
async def __threadname_id_patch(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        cid=(interaction.data or {}).get('custom_id') or ''
        m=__re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m:
            return
        tid=int(m.group(2))

        # thread_id 取得
        try:
            conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("SELECT thread_id,task_name FROM tasks WHERE id=?", (tid,))
            row=cur.fetchone(); conn.close()
        except Exception:
            row=None
        if not row or not row[0]:
            return

        th = interaction.client.get_channel(row[0])
        if not isinstance(th, __dd.Thread):
            try: th = await interaction.client.fetch_channel(row[0])
            except Exception: th=None
        if not isinstance(th, __dd.Thread):
            return

        name = th.name or ""
        # 末尾に #id が無い場合は付ける
        if not __re.search(r"#\d+$", name):
            # 先頭絵文字を保持
            em = name[0] if name[:1] in ("🟥","🟨","🟩","⚠️","❌","⚪") else ""
            # タスク名部分を推定
            base = name
            if em and name[1:].startswith(" "):
                base = name[2:]
            new_name = __tn_format(row[1], em or "⚪", tid)
            await th.edit(name=new_name)
            logger.info(f"[thread-name-id] appended: '{name}' -> '{new_name}'")
    except Exception as e:
        logger.error(f"[thread-name-id] failed: {e}", exc_info=True)
# ==== /THREAD_NAME_ID ====

# ==== LINK_RENAME (handle_task_action内で強制連動) ====
import sqlite3 as _sq, discord as _dd, asyncio as _aio, re as _re

def _link_emoji(status):
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status,"⚪")

def _link_desired(action):
    return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
            "abandon_task":"abandoned","decline_task":"declined"}.get(action)

async def _link_find_or_save_thread(interaction, task_id, task_name):
    # 1) DBに thread_id があればそれを使う
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        row=c.fetchone(); c.connection.close()
    except Exception: row=None
    th=None
    if row and row[0]:
        th = interaction.client.get_channel(row[0])
        if not isinstance(th,_dd.Thread):
            try: th = await interaction.client.fetch_channel(row[0])
            except Exception: th=None
        if isinstance(th,_dd.Thread):
            return th

    # 2) 文脈から特定（スレッド内→channel、親→message.thread、なければ親chのthreads）
    msg=interaction.message
    th = msg.channel if isinstance(msg.channel,_dd.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_dd.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None

    # 3) 見つかったらDBに保存
    if isinstance(th,_dd.Thread):
        try:
            conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
            conn.commit(); conn.close()
        except Exception: pass
    return th

# 既存の handle_task_action を上書き：元の処理→連動リネームの順で実施
__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    # 1) まず元の処理を実行（ステータス更新・Embed切替など）
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    # 2) アクション→目標ステータス
    desired = _link_desired(action)
    if not desired: 
        return

    # 3) タスク名を取得（Embedタイトル or DB）
    task_name = None
    try:
        if interaction.message.embeds:
            title = (interaction.message.embeds[0].title or "").strip()
            task_name = title[2:].strip() if title.startswith("📋") else title
    except Exception:
        task_name=None
    if not task_name:
        try:
            c=_sq.connect('reminder_bot.db').cursor()
            c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            task_name = r[0] if r else None
        except Exception:
            task_name=None

    # 4) 対象スレッドを特定（必要なら保存）
    th = await _link_find_or_save_thread(interaction, task_id, task_name)
    if not isinstance(th,_dd.Thread):
        # 少し遅延後にもう一度（作成直後の競合回避）
        await _aio.sleep(0.25)
        th = await _link_find_or_save_thread(interaction, task_id, task_name)
        if not isinstance(th,_dd.Thread):
            return

    # 5) 権限チェック
    me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p = th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    # 6) スレッド名の先頭絵文字を差し替え（🟥/🟨/🟩/⚠️/❌）
    cur = th.name or ""
    em  = _link_emoji(desired)
    for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
        if cur.startswith(e):
            new = em + cur[len(e):]
            break
    else:
        new = f"{em} {cur}"
    new=new.lstrip()

    if new != cur:
        await th.edit(name=new)
        logger.info(f"[link-rename] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link-rename] no change: '{cur}' (action={action})")
# ==== /LINK_RENAME ====

# ==== RENAME_AGGREGATOR (debounce duplicate thread.edit calls) ====
import asyncio as __aio, time as __time, discord as __dd

if not hasattr(__dd.Thread, "_orig_edit"):
    __dd.Thread._orig_edit = __dd.Thread.edit  # keep original

__rename_state = {}  # thread_id -> {"task":asyncio.Task, "desired":str, "last":float}

async def __rename_worker(thread: __dd.Thread):
    st = __rename_state.setdefault(thread.id, {})
    # ちょい待って“最後の希望名”に合わせる
    await __aio.sleep(0.25)
    name = st.get("desired")
    try:
        await __dd.Thread._orig_edit(thread, name=name)
    except Exception as e:
        # 失敗しても潰さない（429などは外で再試行する）
        pass
    finally:
        st["last"] = __time.monotonic()
        st["task"] = None

async def __patched_edit(self: __dd.Thread, *args, **kwargs):
    name = kwargs.get("name", None)
    # name を変えない編集は素通し
    if name is None:
        return await __dd.Thread._orig_edit(self, *args, **kwargs)

    st = __rename_state.setdefault(self.id, {})
    st["desired"] = name  # 常に“最新の希望名”を上書き
    # 直近で動いていなければワーカー起動、動いていれば合流（1回に集約）
    if not st.get("task"):
        st["task"] = __aio.create_task(__rename_worker(self))
    # 呼び出し側はワーカー完了を待つ（同期待ちで整合）
    await st["task"]
    return self

# 一度だけパッチ
__dd.Thread.edit = __patched_edit
# ==== /RENAME_AGGREGATOR ====

if __name__ == "__main__":
    token=os.getenv("DISCORD_BOT_TOKEN")
    if not token:
        raise SystemExit("DISCORD_BOT_TOKEN が未設定です。export DISCORD_BOT_TOKEN=... で設定してください。")
    bot.run(token)
# ==== HOTFIX: verbose on_command_error ====
@bot.event
async def on_command_error(ctx, error):
    try:
        logger.error(f"[CMD:{getattr(ctx.command,'name',None)}] Uncaught command error", exc_info=True)
    finally:
        try:
            await ctx.send("❌ コマンド実行中にエラーが発生しました。（詳細はログ）")
        except Exception:
            pass
# ==== /HOTFIX ====
@bot.event
async def on_command_error(ctx, error):
    try:
        logger.error(f"[CMD:{getattr(ctx.command,'name',None)}] Uncaught command error", exc_info=True)
    finally:
        try:
            await ctx.send("❌ コマンド実行中にエラーが発生しました。（詳細はログ）")
        except Exception:
            pass
# ==== HOTFIX (safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

# 1) DatabaseManager.add_task を必ず ID を返す実装に差し替え
def __fixed_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fixed_add_task)
except NameError:
    pass

# 2) send_task_notification を 7引数・task_id 省略可の安全版に差し替え
async def __fixed_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("Task not found just after insert (fallback search failed).")
                return
            task_id = row[0][0]

        ch_name = f"to-{assignee.display_name}"
        ch = _discord.utils.get(guild.channels, name=ch_name)
        if not ch:
            try:
                ow = {
                    guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                    assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True),
                }
                ch = await guild.create_text_channel(ch_name, overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
                intro = _discord.Embed(title="📋 個人タスクチャンネル",
                                       description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                                       color=_discord.Color.blue())
                intro.add_field(name="機能", value="• タスク通知の受信\n• タスクの受託・完了報告\n• 進捗状況の確認", inline=False)
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"Failed to create personal channel/DM: {e}")
                    return

        embed = _discord.Embed(
            title=f"📋 {task_name}",
            description=f"**期日: {due_date.strftime('%Y/%m/%d %H:%M')}**",
            color=_discord.Color.gold()
        )
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            thread = await msg.create_thread(name=f"🟥 {task_name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
            detail = _discord.Embed(title="📋 タスク詳細", color=_discord.Color.blue())
            detail.add_field(name="指示者", value=instructor.mention, inline=True)
            detail.add_field(name="状態", value="🟥 未受託", inline=True)
            detail.add_field(name="作成日時", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await thread.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"__fixed_send_task_notification error: {e}", exc_info=True)

try:
    send_task_notification = __fixed_send_task_notification
except NameError:
    pass

# 3) !test を未定義変数なしの完成版で再登録
try:
    bot.remove_command('test')
    bot.remove_command('テスト')
except Exception:
    pass

@bot.command(name='テスト', aliases=['test'])
async def __fixed_test(ctx):
    try:
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="テストタスク",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("❌ タスク作成に失敗しました。（直後確認NG）")
            return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "テストタスク", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="🧪 テストタスク作成", description="タスク作成機能のテストが成功しました！", color=_discord.Color.green())
        ok.add_field(name="タスクID", value=str(task_id), inline=True)
        ok.add_field(name="期日", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"fixed test error: {e}", exc_info=True)
        await ctx.send("❌ テスト中にエラーが発生しました。")
# ==== /HOTFIX ====
# ==== HOTFIX (safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

# 1) DatabaseManager.add_task を必ず ID を返す実装に差し替え
def __fixed_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fixed_add_task)
except NameError:
    pass

# 2) send_task_notification を 7引数・task_id 省略可の安全版に差し替え
async def __fixed_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("Task not found just after insert (fallback search failed).")
                return
            task_id = row[0][0]

        ch_name = f"to-{assignee.display_name}"
        ch = _discord.utils.get(guild.channels, name=ch_name)
        if not ch:
            try:
                ow = {
                    guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                    assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True),
                }
                ch = await guild.create_text_channel(ch_name, overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
                intro = _discord.Embed(title="📋 個人タスクチャンネル",
                                       description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                                       color=_discord.Color.blue())
                intro.add_field(name="機能", value="• タスク通知の受信\n• タスクの受託・完了報告\n• 進捗状況の確認", inline=False)
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"Failed to create personal channel/DM: {e}")
                    return

        embed = _discord.Embed(
            title=f"📋 {task_name}",
            description=f"**期日: {due_date.strftime('%Y/%m/%d %H:%M')}**",
            color=_discord.Color.gold()
        )
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            thread = await msg.create_thread(name=f"🟥 {task_name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
            detail = _discord.Embed(title="📋 タスク詳細", color=_discord.Color.blue())
            detail.add_field(name="指示者", value=instructor.mention, inline=True)
            detail.add_field(name="状態", value="🟥 未受託", inline=True)
            detail.add_field(name="作成日時", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await thread.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"__fixed_send_task_notification error: {e}", exc_info=True)

try:
    send_task_notification = __fixed_send_task_notification
except NameError:
    pass

# 3) !test を未定義変数なしの完成版で再登録
try:
    bot.remove_command('test')
    bot.remove_command('テスト')
except Exception:
    pass

@bot.command(name='テスト', aliases=['test'])
async def __fixed_test(ctx):
    try:
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="テストタスク",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("❌ タスク作成に失敗しました。（直後確認NG）")
            return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "テストタスク", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="🧪 テストタスク作成", description="タスク作成機能のテストが成功しました！", color=_discord.Color.green())
        ok.add_field(name="タスクID", value=str(task_id), inline=True)
        ok.add_field(name="期日", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"fixed test error: {e}", exc_info=True)
        await ctx.send("❌ テスト中にエラーが発生しました。")
# ==== /HOTFIX ====
# ==== HOTFIX2 (DB直叩き・安全上書き) ====
import sqlite3 as _sqlite3, datetime as _dt, discord as _discord

def __q(sql, params=()):
    conn=_sqlite3.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params); rows=cur.fetchall()
    conn.commit(); conn.close(); return rows

# add_task と send_task_notification を DB直叩きで動く形に（既存があっても下で再バインド）
def __fx2_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn=_sqlite3.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) VALUES (?,?,?,?,?,?,?)",
                (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id))
    tid=cur.lastrowid; conn.commit(); conn.close()
    return tid

async def __fx2_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id=None):
    try:
        if task_id is None:
            row=__q("SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? ORDER BY created_at DESC LIMIT 1",
                    (guild.id, assignee.id, task_name))
            if not row: 
                logger.error("[HOTFIX2] task lookup failed"); return
            task_id=row[0][0]

        ch=_discord.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow={guild.default_role:_discord.PermissionOverwrite(read_messages=False),
                    assignee:_discord.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch=await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}の個人タスク管理チャンネル")
                intro=_discord.Embed(title="📋 個人タスクチャンネル",
                                     description=f"こんにちは、{assignee.display_name}さん！\nこのチャンネルでタスクの通知を受け取ります。",
                                     color=_discord.Color.blue())
                await ch.send(embed=intro)
            except Exception:
                try: ch=await assignee.create_dm()
                except: return

        embed=_discord.Embed(title=f"📋 {task_name}", description=f"**期日: {due_date.strftime('%Y/%m/%d %H:%M')}**", color=_discord.Color.gold())
        view=TaskView(task_id, assignee.id, instructor.id, "pending")
        msg=await ch.send(assignee.mention, embed=embed, view=view)

        try:
            th=await msg.create_thread(name=f"🟥 {task_name} - 詳細", auto_archive_duration=60, reason="タスク詳細情報")
            detail=_discord.Embed(title="📋 タスク詳細", color=_discord.Color.blue())
            detail.add_field(name="指示者", value=instructor.mention, inline=True)
            detail.add_field(name="状態", value="🟥 未受託", inline=True)
            detail.add_field(name="作成日時", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await th.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"[HOTFIX2] send_task_notification error: {e}", exc_info=True)

# 既存実装を上書き
try:
    DatabaseManager.add_task = staticmethod(__fx2_add_task)
except Exception:
    pass
send_task_notification = __fx2_send_task_notification

# !test を DB直叩きで再登録
try:
    bot.remove_command('test'); bot.remove_command('テスト')
except Exception:
    pass

@bot.command(name='テスト', aliases=['test'])
async def __fx2_test(ctx):
    try:
        due=_dt.datetime.now()+_dt.timedelta(days=1)
        due=due.replace(hour=23,minute=59,second=0,microsecond=0)
        task_id=__fx2_add_task(ctx.guild.id, ctx.author.id, ctx.author.id, "テストタスク", due, ctx.message.id, ctx.channel.id)
        if not __q("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("❌ タスク作成に失敗しました。（直後確認NG）"); return
        await __fx2_send_task_notification(ctx.guild, ctx.author, ctx.author, "テストタスク", due, ctx.message.id, task_id=task_id)
        ok=_discord.Embed(title="🧪 テストタスク作成", description="タスク作成機能のテストが成功しました！", color=_discord.Color.green())
        ok.add_field(name="タスクID", value=str(task_id), inline=True)
        ok.add_field(name="期日", value=due.strftime('%Y/%m/%d %H:%M'), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[HOTFIX2] test error: {e}", exc_info=True)
        await ctx.send("❌ テスト中にエラーが発生しました。")
# ==== /HOTFIX2 ====
# ==== HOTFIX_THREAD_RENAME ====
import re as __re
import discord as __dd

async def update_thread_name(message, status: str):
    """状態に応じてスレッド名先頭の絵文字を更新（🟥/🟨/🟩/⚠️/❌に対応）"""
    try:
        # スレッド内の操作なら channel が Thread、親チャンネル側なら message.thread が Thread
        thread = message.channel if isinstance(message.channel, __dd.Thread) else getattr(message, "thread", None)
        if not isinstance(thread, __dd.Thread):
            return

        current = thread.name or ""
        status_emojis = {
            "pending":   "🟥",  # 未受託
            "accepted":  "🟨",  # 受託
            "completed": "🟩",  # 完了
            "abandoned": "⚠️",  # 問題発生
            "declined":  "❌",  # 辞退
        }
        emoji = status_emojis.get(status, "⚪")

        # 既存の先頭絵文字があれば置換、なければ付与
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = emoji + current[len(e):]
                break
        else:
            new_name = f"{emoji} {current}"

        # 余分な空白を整理
        new_name = __re.sub(r"^\s+", "", new_name)
        await thread.edit(name=new_name)
        logger.info(f"Thread name updated to: {new_name}")
    except Exception as e:
        logger.error(f"Failed to update thread name: {e}", exc_info=True)
# ==== /HOTFIX_THREAD_RENAME ====
# ==== HOTFIX_THREAD_RENAME v2 ====
import re as __re
import discord as __dd

async def update_thread_name(message, status: str):
    """状態に応じてスレッド名先頭の絵文字を更新（🟥/🟨/🟩/⚠️/❌）"""
    try:
        # ボタンが押された場所がスレッドか、親メッセージの thread 属性かの両方に対応
        thread = message.channel if isinstance(message.channel, __dd.Thread) else getattr(message, "thread", None)
        if not isinstance(thread, __dd.Thread):
            logger.info("[rename] skip: not a thread message")
            return

        current = thread.name or ""
        status_emojis = {
            "pending":   "🟥",
            "accepted":  "🟨",
            "completed": "🟩",
            "abandoned": "⚠️",
            "declined":  "❌",
        }
        emoji = status_emojis.get(status, "⚪")

        # 既存先頭絵文字の置換 or 付与
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = emoji + current[len(e):]
                break
        else:
            new_name = f"{emoji} {current}"

        new_name = __re.sub(r"^\s+", "", new_name)
        if new_name != current:
            await thread.edit(name=new_name)
            logger.info(f"[rename] Thread name updated: '{current}' -> '{new_name}' ({status})")
        else:
            logger.info(f"[rename] no change: '{current}' ({status})")
    except Exception as e:
        logger.error(f"[rename] failed: {e}", exc_info=True)
# ==== /HOTFIX_THREAD_RENAME v2 ====
# ==== HOTFIX_THREAD_WRAP ====
import discord as __dd

# 既存の handle_task_action を退避して、呼び出し後に必ずリネームを走らせるラッパを定義
__orig_handle_task_action = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    # まず元の処理を実行（Embed更新・DB更新など）
    if callable(__orig_handle_task_action):
        await __orig_handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status)

    # アクション→ステータスに変換して、スレッド名の絵文字を更新
    status_map = {
        "accept_task": "accepted",
        "decline_task": "declined",
        "complete_task": "completed",
        "abandon_task": "abandoned",
        "undo_completion": "accepted",
    }
    new_status = status_map.get(action)
    if not new_status:
        return

    try:
        # thread は「ボタンを押したメッセージがあるスレッド」もしくは「親メッセージの thread」どちらにも対応
        thread = interaction.message.channel if isinstance(interaction.message.channel, __dd.Thread) else getattr(interaction.message, "thread", None)
        if not isinstance(thread, __dd.Thread):
            logger.info("[rename-wrap] skip: not thread")
            return

        current = thread.name or ""
        status_emojis = {"pending":"��","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}
        emoji = status_emojis.get(new_status, "⚪")

        # 先頭の絵文字を置換／付与
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = emoji + current[len(e):]
                break
        else:
            new_name = f"{emoji} {current}"

        new_name = new_name.lstrip()
        if new_name != current:
            await thread.edit(name=new_name)
            logger.info(f"[rename-wrap] Thread name updated: '{current}' -> '{new_name}' ({new_status})")
        else:
            logger.info(f"[rename-wrap] no change: '{current}' ({new_status})")
    except Exception as e:
        logger.error(f"[rename-wrap] failed: {e}", exc_info=True)
# ==== /HOTFIX_THREAD_WRAP ====
@bot.command(name='perms_threads')
async def perms_threads(ctx):
    m = ctx.guild.get_member(bot.user.id)
    ch = ctx.channel
    p = ch.permissions_for(m)
    lines = [
        f"manage_threads: {p.manage_threads}",
        f"create_public_threads: {p.create_public_threads}",
        f"create_private_threads: {getattr(p,'create_private_threads', 'n/a')}",
        f"send_messages_in_threads: {p.send_messages_in_threads}",
        f"manage_channels: {p.manage_channels}",
    ]
    await ctx.send("```" + "\n".join(lines) + "```")
@bot.command(name='perms_threads')
async def perms_threads(ctx):
    m = ctx.guild.get_member(bot.user.id)
    ch = ctx.channel
    p = ch.permissions_for(m)
    lines = [
        f"manage_threads: {p.manage_threads}",
        f"create_public_threads: {p.create_public_threads}",
        f"create_private_threads: {getattr(p,'create_private_threads', 'n/a')}",
        f"send_messages_in_threads: {p.send_messages_in_threads}",
        f"manage_channels: {p.manage_channels}",
    ]
    await ctx.send("```" + "\n".join(lines) + "```")
# ==== WRAP_BLOCK v3 (robust thread rename) ====
import re as __re
import discord as __dd
logger.info("[wrap-load v3] handle_task_action wrapper installed")

__orig_handle_task_action = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    # 1) 先に元の処理を実行（DB/Embed更新など）
    if callable(__orig_handle_task_action):
        await __orig_handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status)

    # 2) アクション→状態マップ
    status_map = {
        "accept_task": "accepted",
        "decline_task": "declined",
        "complete_task": "completed",
        "abandon_task": "abandoned",
        "undo_completion": "accepted",
    }
    new_status = status_map.get(action)
    if not new_status:
        return

    try:
        # 3) スレッドを特定：スレッド内→channel が Thread / 親メッセージ→message.thread
        msg = interaction.message
        thread = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg, "thread", None)

        # 4) 見つからなければ、Embedタイトルのタスク名から同チャンネルのスレッドを探索
        if not isinstance(thread, __dd.Thread):
            task_name = None
            try:
                if msg.embeds:
                    title = (msg.embeds[0].title or "").strip()
                    # 先頭の「📋 」を剥がす
                    task_name = title[2:].strip() if title.startswith("📋") else title
            except Exception:
                task_name = None

            candidates = []
            try:
                candidates = list(getattr(msg.channel, "threads", []))
            except Exception:
                candidates = []

            if task_name and candidates:
                for th in candidates:
                    if task_name in (th.name or ""):
                        thread = th
                        break

        if not isinstance(thread, __dd.Thread):
            logger.info("[rename-wrap] skip: no thread found")
            return

        # 5) スレッド名の先頭絵文字を状態に応じて差し替え
        current = thread.name or ""
        status_emojis = {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}
        emoji = status_emojis.get(new_status, "⚪")

        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = emoji + current[len(e):]
                break
        else:
            new_name = f"{emoji} {current}"

        new_name = new_name.lstrip()
        if new_name != current:
            await thread.edit(name=new_name)
            logger.info(f"[rename-wrap] updated: '{current}' -> '{new_name}' ({new_status})")
        else:
            logger.info(f"[rename-wrap] no change: '{current}' ({new_status})")
    except Exception as e:
        logger.error(f"[rename-wrap] failed: {e}", exc_info=True)
# ==== /WRAP_BLOCK v3 ====
# ==== LISTENER_RENAME (robust after-interaction thread rename) ====
import re as ___re, asyncio as ___aio, sqlite3 as ___sq, discord as ___dd

@bot.listen('on_interaction')
async def ___rename_after_interaction(interaction: ___dd.Interaction):
    try:
        if interaction.type != ___dd.InteractionType.component:
            return
        cid = (interaction.data or {}).get('custom_id') or ''
        # custom_id の末尾から task_id を取る（accept_task_123 など）
        m = ___re.search(r'_(\d+)$', cid)
        if not m:
            return
        task_id = int(m.group(1))

        # 元の更新が終わるのを待つ
        await ___aio.sleep(0.35)

        # DBから最新status取得
        try:
            conn = ___sq.connect('reminder_bot.db'); cur = conn.cursor()
            cur.execute("SELECT status FROM tasks WHERE id=?", (task_id,))
            row = cur.fetchone()
            conn.close()
        except Exception as e:
            logger.error(f"[rename-listener] DB error: {e}", exc_info=True); return
        if not row:
            logger.info("[rename-listener] task not found"); return
        status = row[0]

        # スレッド特定：スレッド内なら channel が Thread、親メッセージなら message.thread
        msg = interaction.message
        thread = msg.channel if isinstance(msg.channel, ___dd.Thread) else getattr(msg, "thread", None)

        # 見つからなければ、親チャンネルで「タスク名 - 詳細」っぽいスレッドを探索（Embedタイトルから）
        if not isinstance(thread, ___dd.Thread):
            task_name = None
            try:
                if msg.embeds:
                    title = (msg.embeds[0].title or "").strip()
                    task_name = title[2:].strip() if title.startswith("📋") else title
            except Exception:
                task_name = None
            try:
                for th in getattr(msg.channel, "threads", []):
                    if task_name and task_name in (th.name or ""):
                        thread = th; break
            except Exception:
                pass

        if not isinstance(thread, ___dd.Thread):
            logger.info("[rename-listener] skip: no thread")
            return

        # 権限チェック（あれば実行）
        me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
        if me:
            p = thread.permissions_for(me)
            if not (getattr(p, "manage_threads", False) or getattr(p, "manage_channels", False)):
                logger.info("[rename-listener] skip: no permission to rename")
                return

        # ステータスに応じて絵文字
        em = {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status, "⚪")
        current = thread.name or ""
        for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
            if current.startswith(e):
                new_name = em + current[len(e):]; break
        else:
            new_name = f"{em} {current}"
        new_name = new_name.lstrip()

        if new_name != current:
            await thread.edit(name=new_name)
            logger.info(f"[rename-listener] updated: '{current}' -> '{new_name}' (status={status})")
        else:
            logger.info(f"[rename-listener] no change: '{current}' ({status})")
    except Exception as e:
        logger.error(f"[rename-listener] failed: {e}", exc_info=True)
# ==== /LISTENER_RENAME ====
# ==== RENAME_RETRY (handles undo→accepted reliably) ====
import asyncio as __aio, sqlite3 as __sq, re as __re, discord as __dd

def __emoji_for_status(s):
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(s, "⚪")

def __pick_thread(msg: __dd.Message, task_name: str):
    th = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg, "thread", None)
    if isinstance(th, __dd.Thread):
        return th
    try:
        for t in getattr(msg.channel, "threads", []):
            if task_name and task_name in (t.name or ""):
                return t
    except Exception:
        pass
    return None

@bot.listen('on_interaction')
async def __rename_retry_listener(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        data = interaction.data or {}
        cid  = data.get('custom_id') or ''
        m = __re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m:
            return
        action, tid = m.group(1), int(m.group(2))

        desired = {
            "accept_task": "accepted",
            "decline_task": "declined",
            "complete_task": "completed",
            "abandon_task": "abandoned",
            "undo_completion": "accepted",   # ← 戻すときは必ず accepted にしたい
        }[action]

        # 元の処理完了待ち + リトライ（最大5回・1.0秒）
        for attempt in range(5):
            if attempt == 0:
                await __aio.sleep(0.40)
            else:
                await __aio.sleep(0.15)

            # DBから現状ステータス取得
            try:
                conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                cur.execute("SELECT task_name,status FROM tasks WHERE id=?", (tid,))
                row = cur.fetchone()
                conn.close()
            except Exception as e:
                logger.error(f"[rename-retry] DB error: {e}", exc_info=True)
                return
            if not row:
                logger.info("[rename-retry] task not found")
                return

            task_name, status = row[0], row[1]

            # 望ましい状態になっていない場合は、undo は desired を、他は DB の status を使う
            target_status = desired if action == "undo_completion" else status

            # スレッド特定
            msg = interaction.message
            th  = __pick_thread(msg, task_name)
            if not isinstance(th, __dd.Thread):
                # まだスレッドが見つからないなら次の試行へ
                continue

            # 権限
            me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
            if me:
                p = th.permissions_for(me)
                if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                    logger.info("[rename-retry] no permission to rename")
                    return

            current = th.name or ""
            em  = __emoji_for_status(target_status)
            for e in ["🟥","🟨","��","⚠️","❌","⚪"]:
                if current.startswith(e):
                    new = em + current[len(e):]
                    break
            else:
                new = f"{em} {current}"
            new = new.lstrip()

            if new != current:
                await th.edit(name=new)
                logger.info(f"[rename-retry] updated: '{current}' -> '{new}' (status={target_status}, id={tid}, try={attempt})")
                return
            else:
                # 望ましい絵文字と同じなら終了、違うのに同じだった場合は少し待って再試行
                if current.startswith(em):
                    logger.info(f"[rename-retry] already ok: '{current}' (status={target_status})")
                    return
                continue

        logger.info(f"[rename-retry] giving up (id={tid})")
    except Exception as e:
        logger.error(f"[rename-retry] failed: {e}", exc_info=True)
# ==== /RENAME_RETRY ====
# ==== RENAME_FIX_BACKFILL (auto backfill thread_id then rename) ====
import asyncio as __aio, sqlite3 as __sq, re as __re, discord as __dd

def __rf_emoji(status:str)->str:
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status,"⚪")

def __rf_find_thread_by_context(msg: __dd.Message, task_name:str):
    th = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg, "thread", None)
    if isinstance(th, __dd.Thread):
        return th
    try:
        for t in getattr(msg.channel, "threads", []):  # active threads
            if task_name and task_name in (t.name or ""):
                return t
    except Exception:
        pass
    return None

@bot.listen('on_interaction')
async def __rename_fix_backfill(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        cid = (interaction.data or {}).get('custom_id') or ''
        m = __re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m:
            return
        action, tid = m.group(1), int(m.group(2))
        desired = {"accept_task":"accepted","decline_task":"declined","complete_task":"completed",
                   "abandon_task":"abandoned","undo_completion":"accepted"}[action]

        # 元処理の反映待ち + 短いリトライ
        for attempt in range(6):
            await __aio.sleep(0.20 if attempt else 0.40)

            # DBから現状取得
            conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
            cur.execute("SELECT thread_id,status,task_name FROM tasks WHERE id=?", (tid,))
            row = cur.fetchone()
            conn.close()
            if not row:
                return
            thread_id, status, task_name = row
            target_status = desired if action=="undo_completion" else status

            th = None
            if thread_id:
                th = interaction.client.get_channel(thread_id)
                if not isinstance(th, __dd.Thread):
                    try: th = await interaction.client.fetch_channel(thread_id)
                    except Exception: th = None

            # thread_id が未設定/取得失敗なら文脈から探索→DBへ保存
            if not isinstance(th, __dd.Thread):
                th = __rf_find_thread_by_context(interaction.message, task_name)
                if isinstance(th, __dd.Thread):
                    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                    cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, tid))
                    conn.commit(); conn.close()

            if not isinstance(th, __dd.Thread):
                continue  # 次の試行

            # 権限チェック
            me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
            if me:
                p = th.permissions_for(me)
                if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                    return

            cur_name = th.name or ""
            em = __rf_emoji(target_status)
            for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
                if cur_name.startswith(e):
                    new_name = em + cur_name[len(e):]; break
            else:
                new_name = f"{em} {cur_name}"
            new_name = new_name.lstrip()

            if new_name != cur_name:
                await th.edit(name=new_name)
                logger.info(f"[rename-fix] updated: '{cur_name}' -> '{new_name}' (status={target_status}, id={tid}, try={attempt})")
            else:
                logger.info(f"[rename-fix] no change: '{cur_name}' (status={target_status}, id={tid})")
            return

        logger.info(f"[rename-fix] giving up (id={tid})")
    except Exception as e:
        logger.error(f"[rename-fix] failed: {e}", exc_info=True)
# ==== /RENAME_FIX_BACKFILL ====
# ==== RENAME_FIX_BACKFILL (auto backfill thread_id then rename) ====
import asyncio as __aio, sqlite3 as __sq, re as __re, discord as __dd

def __rf_emoji(status:str)->str:
    return {"pending":"🟥","accepted":"🟨","completed":"🟩","abandoned":"⚠️","declined":"❌"}.get(status,"⚪")

def __rf_find_thread_by_context(msg: __dd.Message, task_name:str):
    th = msg.channel if isinstance(msg.channel, __dd.Thread) else getattr(msg, "thread", None)
    if isinstance(th, __dd.Thread):
        return th
    try:
        for t in getattr(msg.channel, "threads", []):  # active threads
            if task_name and task_name in (t.name or ""):
                return t
    except Exception:
        pass
    return None

@bot.listen('on_interaction')
async def __rename_fix_backfill(interaction: __dd.Interaction):
    try:
        if interaction.type != __dd.InteractionType.component:
            return
        cid = (interaction.data or {}).get('custom_id') or ''
        m = __re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m:
            return
        action, tid = m.group(1), int(m.group(2))
        desired = {"accept_task":"accepted","decline_task":"declined","complete_task":"completed",
                   "abandon_task":"abandoned","undo_completion":"accepted"}[action]

        # 元処理の反映待ち + 短いリトライ
        for attempt in range(6):
            await __aio.sleep(0.20 if attempt else 0.40)

            # DBから現状取得
            conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
            cur.execute("SELECT thread_id,status,task_name FROM tasks WHERE id=?", (tid,))
            row = cur.fetchone()
            conn.close()
            if not row:
                return
            thread_id, status, task_name = row
            target_status = desired if action=="undo_completion" else status

            th = None
            if thread_id:
                th = interaction.client.get_channel(thread_id)
                if not isinstance(th, __dd.Thread):
                    try: th = await interaction.client.fetch_channel(thread_id)
                    except Exception: th = None

            # thread_id が未設定/取得失敗なら文脈から探索→DBへ保存
            if not isinstance(th, __dd.Thread):
                th = __rf_find_thread_by_context(interaction.message, task_name)
                if isinstance(th, __dd.Thread):
                    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                    cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, tid))
                    conn.commit(); conn.close()

            if not isinstance(th, __dd.Thread):
                continue  # 次の試行

            # 権限チェック
            me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
            if me:
                p = th.permissions_for(me)
                if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                    return

            cur_name = th.name or ""
            em = __rf_emoji(target_status)
            for e in ["🟥","🟨","🟩","⚠️","❌","⚪"]:
                if cur_name.startswith(e):
                    new_name = em + cur_name[len(e):]; break
            else:
                new_name = f"{em} {cur_name}"
            new_name = new_name.lstrip()

            if new_name != cur_name:
                await th.edit(name=new_name)
                logger.info(f"[rename-fix] updated: '{cur_name}' -> '{new_name}' (status={target_status}, id={tid}, try={attempt})")
            else:
                logger.info(f"[rename-fix] no change: '{cur_name}' (status={target_status}, id={tid})")
            return

        logger.info(f"[rename-fix] giving up (id={tid})")
    except Exception as e:
        logger.error(f"[rename-fix] failed: {e}", exc_info=True)
# ==== /RENAME_FIX_BACKFILL ====
