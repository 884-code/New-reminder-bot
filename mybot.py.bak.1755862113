# -*- coding: utf-8 -*-
# mybot.py (failsafe setup edition)
import os, re, json, sqlite3, logging, asyncio
from datetime import datetime, timedelta
from typing import Optional, List

import discord
from discord import app_commands
from discord.ext import commands, tasks

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)-8s %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("bot.log", encoding="utf-8")]
)
logger = logging.getLogger("taskbot")

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.message_content = True

bot = commands.Bot(
    command_prefix=commands.when_mentioned_or("!", "ï¼", "/"),
    intents=intents,
    case_insensitive=True,
    help_command=None,
    max_messages=100,
)

DB_PATH = "reminder_bot.db"
def db_exec(q: str, params: tuple = (), fetch=False):
    conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
    cur.execute(q, params); rows = cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

def init_db():
    db_exec("""CREATE TABLE IF NOT EXISTS admins(user_id INTEGER, guild_id INTEGER, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS instructors(user_id INTEGER, guild_id INTEGER, target_users TEXT, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS tasks(
        id INTEGER PRIMARY KEY AUTOINCREMENT, guild_id INTEGER, instructor_id INTEGER, assignee_id INTEGER,
        task_name TEXT, due_date TIMESTAMP, status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        message_id INTEGER, channel_id INTEGER, reminder_sent INTEGER DEFAULT 0)""")
    cols = db_exec("PRAGMA table_info(tasks)", fetch=True)
    if "reminder_sent" not in [c[1] for c in cols]:
        db_exec("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")

def is_admin(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM admins WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))
def is_instructor(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM instructors WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))

def insert_task(gid:int,iid:int,aid:int,name:str,due:datetime)->int:
    db_exec("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date) VALUES (?,?,?,?,?)", (gid,iid,aid,name,due))
    return db_exec("SELECT last_insert_rowid()", fetch=True)[0][0]

def get_task(tid:int):
    r=db_exec("SELECT * FROM tasks WHERE id=?", (tid,), fetch=True)
    return r[0] if r else None

async def ensure_mgmt(guild:discord.Guild)->Optional[discord.TextChannel]:
    for name in ("task-management","ã‚¿ã‚¹ã‚¯ç®¡ç†"):
        ch = discord.utils.get(guild.channels, name=name)
        if isinstance(ch, discord.TextChannel): return ch
    try:
        return await guild.create_text_channel("task-management", overwrites={guild.default_role: discord.PermissionOverwrite(read_messages=False)})
    except Exception as e:
        logger.error(f"mgmt create failed: {e}"); return None

async def ensure_personal(guild:discord.Guild,user:discord.Member)->Optional[discord.TextChannel]:
    name=f"to-{user.display_name}".lower().replace(" ","-")
    ch=discord.utils.get(guild.channels,name=name)
    if isinstance(ch,discord.TextChannel): return ch
    try:
        ow={guild.default_role: discord.PermissionOverwrite(read_messages=False), user: discord.PermissionOverwrite(read_messages=True, send_messages=True)}
        return await guild.create_text_channel(name=name, overwrites=ow, topic=f"{user.display_name} ã®å€‹äººã‚¿ã‚¹ã‚¯")
    except Exception as e:
        logger.error(f"personal create failed: {e}"); return None

def parse_date(s:str)->Optional[datetime]:
    now=datetime.now(); t=s.strip().lower()
    m=re.search(r'(\d{1,2}):(\d{2})$',t)
    if m: hour,minute=int(m.group(1)),int(m.group(2)); t=t[:m.start()].strip()
    else: hour,minute=23,59
    pats=[(r'^(ä»Šæ—¥|today)$',lambda m:now),(r'^(æ˜æ—¥|tomorrow)$',lambda m:now+timedelta(days=1)),
          (r'^(æ˜å¾Œæ—¥|day after tomorrow)$',lambda m:now+timedelta(days=2)),(r'^(æ˜¨æ—¥|yesterday)$',lambda m:now-timedelta(days=1)),
          (r'^(\d+)\s*(æ—¥å¾Œ|days?)$',lambda m:now+timedelta(days=int(m.group(1)))),
          (r'^(\d+)\s*(é€±é–“å¾Œ|weeks?)$',lambda m:now+timedelta(weeks=int(m.group(1)))),
          (r'^(\d+)\s*(æ™‚é–“å¾Œ|hours?)$',lambda m:now+timedelta(hours=int(m.group(1)))),
          (r'^(\d+)\s*(åˆ†å¾Œ|mins?|minutes?)$',lambda m:now+timedelta(minutes=int(m.group(1)))) ]
    for pat,fn in pats:
        mm=re.match(pat,t)
        if mm: dt=fn(mm); return dt.replace(hour=hour,minute=minute,second=0,microsecond=0)
    wk={'æœˆ':0,'ç«':1,'æ°´':2,'æœ¨':3,'é‡‘':4,'åœŸ':5,'æ—¥':6,'monday':0,'tuesday':1,'wednesday':2,'thursday':3,'friday':4,'saturday':5,'sunday':6,'mon':0,'tue':1,'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
    for name,num in wk.items():
        if name in t:
            d=num-now.weekday(); d+=7 if d<=0 else 0
            return (now+timedelta(days=d)).replace(hour=hour,minute=minute,second=0,microsecond=0)
    abs_p=[r'^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$',r'^(\d{1,2})[/-](\d{1,2})$',r'^(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥$',r'^(\d{1,2})æœˆ(\d{1,2})æ—¥$']
    for pat in abs_p:
        mm=re.match(pat,t)
        if mm:
            g=mm.groups()
            if len(g)==3 and len(g[0])==4: y,mo,d=int(g[0]),int(g[1]),int(g[2])
            elif len(g)==3: mo,d,y=int(g[0]),int(g[1]),now.year
            else: mo,d,y=int(g[0]),int(g[1]),now.year
            try: return datetime(y,mo,d,hour,minute)
            except ValueError: return None
    return None

STATUS_COLORS={'pending':discord.Color.red(),'accepted':discord.Color.gold(),'completed':discord.Color.green(),'declined':discord.Color.dark_gray(),'abandoned':discord.Color.dark_red()}
STATUS_EMOJI={'pending':'ğŸŸ¥','accepted':'ğŸŸ¨','completed':'ğŸŸ©','declined':'âšª','abandoned':'ğŸŸ«'}
STATUS_NAME={'pending':'Pending','accepted':'In Progress','completed':'Completed','declined':'Declined','abandoned':'Problem'}

def build_embed(trow,status:Optional[str]=None)->discord.Embed:
    st=status or trow[6]
    try: due_ts=int(datetime.fromisoformat(str(trow[5])).timestamp())
    except Exception: due_ts=int(datetime.strptime(str(trow[5]),"%Y-%m-%d %H:%M:%S").timestamp())
    emb=discord.Embed(title=f"ğŸ“‹ {trow[4]}", color=STATUS_COLORS.get(st, discord.Color.blurple()))
    emb.add_field(name="Due Date", value=f"<t:{due_ts}:F>", inline=True)
    emb.add_field(name="Status", value=f"{STATUS_EMOJI.get(st,'âšª')} {STATUS_NAME.get(st,st)}", inline=True)
    emb.add_field(name="Updated", value=f"<t:{int(datetime.now().timestamp())}:R>", inline=True)
    emb.set_footer(text=f"Task ID: {trow[0]}"); return emb

class TaskView(discord.ui.View):
    def __init__(self, tid:int, aid:int, iid:int, status:str):
        super().__init__(timeout=None); self.tid, self.aid, self.iid, self.status=tid,aid,iid,status; self._setup()
    def _setup(self):
        self.clear_items()
        if self.status=='pending': self.add_item(AcceptButton(self.tid)); self.add_item(DeclineButton(self.tid))
        elif self.status=='accepted': self.add_item(CompleteButton(self.tid)); self.add_item(AbandonButton(self.tid))
        elif self.status=='completed': self.add_item(UndoButton(self.tid))

class _BaseBtn(discord.ui.Button):
    def __init__(self,label,style,cid): super().__init__(label=label, style=style, custom_id=cid)
    async def _handle(self,it:discord.Interaction,new_status:str):
        t=db_exec("SELECT * FROM tasks WHERE id=?", (int(self.custom_id.split('_')[-1]),), fetch=True)
        if not t: await it.response.send_message("âŒ Task not found.", ephemeral=True); return
        t=t[0]
        if it.user.id!=t[3]: await it.response.send_message("âŒ You are not the assignee.", ephemeral=True); return
        db_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status,t[0]))
        t2=db_exec("SELECT * FROM tasks WHERE id=?", (t[0],), fetch=True)[0]
        await it.response.edit_message(embed=build_embed(t2,new_status), view=TaskView(t2[0],t2[3],t2[2],new_status))

class AcceptButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âœ… Accept", discord.ButtonStyle.success, f"accept_task_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')
class DeclineButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âŒ Decline", discord.ButtonStyle.danger, f"decline_task_{tid}")
    async def callback(self,it): await self._handle(it,'declined')
class CompleteButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("ğŸ“ Complete", discord.ButtonStyle.success, f"complete_task_{tid}")
    async def callback(self,it): await self._handle(it,'completed')
class AbandonButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âš ï¸ Problem", discord.ButtonStyle.danger, f"abandon_task_{tid}")
    async def callback(self,it): await self._handle(it,'abandoned')
class UndoButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("â†©ï¸ Undo", discord.ButtonStyle.secondary, f"undo_completion_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')

@bot.event
async def on_ready():
    logger.info(f"{bot.user} logged in. Guilds={len(bot.guilds)}"); init_db()
    try: logger.info("Text commands: %s", ", ".join(sorted(c.name for c in bot.commands)))
    except Exception: pass
    try:
        for g in bot.guilds: await bot.tree.sync(guild=g)
        logger.info("Slash commands synced.")
    except Exception as e: logger.error(f"Slash sync error: {e}")

@bot.event
async def on_message(message:discord.Message):
    if message.author.bot: return
    text=message.content.strip()
    if re.match(rf"^(?:<@!?{bot.user.id}>\s*)?[/!ï¼]?\s*setup\b", text, flags=re.I):
        ctx=await bot.get_context(message); await setup_cmd(ctx); return
    await bot.process_commands(message)

@bot.command(name="setup", aliases=["init","ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—"])
async def setup_cmd(ctx:commands.Context):
    if not ctx.guild: await ctx.reply("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„"); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (ctx.author.id, ctx.guild.id))
    await ctx.reply("âœ… Setup complete. Use `!channels` â†’ `!test`")

@bot.command(name="channels")
async def channels_cmd(ctx:commands.Context):
    if not ctx.guild: return
    if not is_admin(ctx.author.id, ctx.guild.id): await ctx.reply("âŒ Admin only"); return
    created=[]
    mg=await ensure_mgmt(ctx.guild); 
    if mg: created.append(mg.name)
    cnt=0
    for m in ctx.guild.members:
        if m.bot: continue
        if cnt>=10: break
        ch=await ensure_personal(ctx.guild, m)
        if ch: created.append(ch.name); cnt+=1
        await asyncio.sleep(0.3)
    await ctx.reply("âœ… Channels: " + (", ".join(created) if created else "(none)"))

@bot.command(name="test")
async def test_cmd(ctx:commands.Context):
    if not ctx.guild: return
    due=datetime.now()+timedelta(hours=1, minutes=5)
    tid=insert_task(ctx.guild.id, ctx.author.id, ctx.author.id, "Test Task / ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due)
    task=get_task(tid); ch=await ensure_personal(ctx.guild, ctx.author)
    view=TaskView(tid, ctx.author.id, ctx.author.id, 'pending')
    if ch: await ch.send(ctx.author.mention, embed=build_embed(task), view=view)
    else:
        try: await ctx.author.send(embed=build_embed(task), view=view)
        except: pass
    await ctx.reply(f"âœ… Test created (ID={tid})")

@bot.command(name="ping")
async def ping_cmd(ctx:commands.Context): await ctx.reply("pong")

@bot.tree.command(name="setup", description="Initial setup / åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—")
async def setup_slash(it:discord.Interaction):
    if not it.guild_id: await it.response.send_message("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„", ephemeral=True); return
    db_exec("INSERT OR IGNORE INTO admins(user_id,guild_id) VALUES(?,?)", (it.user.id, it.guild_id))
    await it.response.send_message("âœ… Setup complete. Run `/channels` or `!channels` next.", ephemeral=True)

@bot.tree.command(name="channels", description="Create task channels")
async def channels_slash(it:discord.Interaction):
    if not it.guild: await it.response.send_message("âŒ ã‚µãƒ¼ãƒãƒ¼å†…ã§å®Ÿè¡Œã—ã¦ãã ã•ã„", ephemeral=True); return
    if not is_admin(it.user.id, it.guild.id): await it.response.send_message("âŒ Admin only", ephemeral=True); return
    await it.response.send_message("âœ… OK (use `!channels` too)", ephemeral=True)

@tasks.loop(minutes=5)
async def check_reminders():
    now=datetime.now(); soon=now+timedelta(hours=1)
    rows=db_exec("SELECT id,guild_id,assignee_id,task_name,due_date FROM tasks WHERE status='accepted' AND reminder_sent=0 AND due_date>? AND due_date<=?", (now,soon), fetch=True)
    for tid,gid,aid,tname,due in rows:
        guild=bot.get_guild(gid); 
        if not guild: continue
        user=guild.get_member(aid)
        if not user: continue
        try:
            try: due_ts=int(datetime.fromisoformat(str(due)).timestamp())
            except Exception: due_ts=int(datetime.strptime(str(due), "%Y-%m-%d %H:%M:%S").timestamp())
            emb=discord.Embed(title="â° Task Reminder", description=f"**{tname}**\nDue in less than 1 hour!", color=discord.Color.orange())
            emb.add_field(name="Due", value=f"<t:{due_ts}:F>", inline=True)
            try: await user.send(embed=emb)
            except Exception:
                ch=await ensure_personal(guild,user)
                if ch: await ch.send(user.mention, embed=emb)
            db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))
        except Exception as e:
            logging.error(f"reminder failed: {e}"); db_exec("UPDATE tasks SET reminder_sent=1 WHERE id=?", (tid,))

@check_reminders.before_loop
async def _b1(): await bot.wait_until_ready()
@tasks.loop(minutes=1)
async def heartbeat_check():
    try:
        if heartbeat_check.current_loop % 5 == 0:
            logger.info(f"Heartbeat OK. Guilds={len(bot.guilds)} Latency={round(bot.latency*1000)}ms")
    except Exception as e: logger.error(f"Heartbeat error: {e}")
@heartbeat_check.before_loop
async def _b2(): await bot.wait_until_ready()
@tasks.loop(hours=1)
async def cleanup_memory():
    try:
        if hasattr(bot,"_connection") and hasattr(bot._connection,"_messages"): bot._connection._messages.clear()
        logger.info("Memory cleanup done.")
    except Exception as e: logger.error(f"cleanup error: {e}")
@cleanup_memory.before_loop
async def _b3(): await bot.wait_until_ready()

@bot.event
async def on_command_error(ctx:commands.Context, error:Exception):
    if isinstance(error, commands.CommandNotFound):
        text=ctx.message.content.strip()
        if re.match(r"^[/!ï¼]?\s*setup\b", text, flags=re.I):
            await setup_cmd(ctx); return
        return
    logging.error(f"Command error: {error}", exc_info=True)
    try: await ctx.reply("âŒ An error occurred.")
    except: pass

# ==== HOTFIX (pre-run safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

def __fx_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    logger.info(f"[HOTFIX] add_task inserted id={tid}, assignee={assignee_id}, name={task_name}")
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fx_add_task)
except Exception:
    pass

async def __fx_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("[HOTFIX] task_id lookup failed (no row)"); return
            task_id = row[0][0]
        logger.info(f"[HOTFIX] send_task_notification start task_id={task_id}, assignee={assignee.id}")

        ch = _discord.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow = {guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                      assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch = await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro = _discord.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                       description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                       color=_discord.Color.blue())
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"[HOTFIX] cannot create channel/DM: {e}")
                    return

        embed = _discord.Embed(title=f"ğŸ“‹ {task_name}",
                               description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**",
                               color=_discord.Color.gold())
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            th = await msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
            detail = _discord.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_discord.Color.blue())
            detail.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
            detail.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
            detail.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await th.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception as e:
            logger.warning(f"[HOTFIX] thread create failed: {e}")
    except Exception as e:
        logger.error(f"[HOTFIX] send_task_notification error: {e}", exc_info=True)

send_task_notification = __fx_send_task_notification

try:
    bot.remove_command('test'); bot.remove_command('ãƒ†ã‚¹ãƒˆ')
except Exception:
    pass

@bot.command(name='ãƒ†ã‚¹ãƒˆ', aliases=['test'])
async def __fx_test(ctx):
    try:
        logger.info("[HOTFIX] __fx_test invoked by %s in guild %s", ctx.author.id, ctx.guild.id)
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("âŒ ã‚¿ã‚¹ã‚¯ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ï¼ˆç›´å¾Œç¢ºèªNGï¼‰"); return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ä½œæˆ", description="ã‚¿ã‚¹ã‚¯ä½œæˆæ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼", color=_discord.Color.green())
        ok.add_field(name="ã‚¿ã‚¹ã‚¯ID", value=str(task_id), inline=True)
        ok.add_field(name="æœŸæ—¥", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[HOTFIX] __fx_test error: {e}", exc_info=True)
        await ctx.send("âŒ ãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /HOTFIX (pre-run) ====

# ==== FIX_BLOCK (pre-run, self-contained test & notify) ====
import sqlite3 as __sq, datetime as __dt, discord as __dd

def __fix_db_add_task(gid, iid, aid, name, due, mid, cid):
    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
    cur.execute("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) VALUES (?,?,?,?,?,?,?)",
                (gid, iid, aid, name, due, mid, cid))
    tid = cur.lastrowid
    conn.commit(); conn.close()
    return tid

async def __fix_notify_personal(guild, assignee, instructor, name, due, task_id):
    ch = __dd.utils.get(guild.channels, name=f"to-{assignee.display_name}")
    if not ch:
        try:
            ow = {guild.default_role: __dd.PermissionOverwrite(read_messages=False),
                  assignee: __dd.PermissionOverwrite(read_messages=True, send_messages=True)}
            ch = await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
            intro = __dd.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                               description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                               color=__dd.Color.blue())
            await ch.send(embed=intro)
        except Exception:
            try:
                ch = await assignee.create_dm()
            except:
                return

    emb = __dd.Embed(title=f"ğŸ“‹ {name}", description=f"**æœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}**", color=__dd.Color.gold())
    view = TaskView(task_id, assignee.id, instructor.id, "pending")
    msg = await ch.send(assignee.mention, embed=emb, view=view)
    try:
        th = await msg.create_thread(name=f"ğŸŸ¥ {name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
        d = __dd.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=__dd.Color.blue())
        d.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
        d.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
        d.add_field(name="ä½œæˆæ—¥æ™‚", value=__dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
        await th.send(embed=d, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
    except Exception:
        pass

try:
    bot.remove_command('test'); bot.remove_command('ãƒ†ã‚¹ãƒˆ')
except Exception:
    pass

@bot.command(name='ãƒ†ã‚¹ãƒˆ', aliases=['test'])
async def __fix_test(ctx):
    try:
        due = __dt.datetime.now() + __dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        tid = __fix_db_add_task(ctx.guild.id, ctx.author.id, ctx.author.id, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, ctx.channel.id)
        await __fix_notify_personal(ctx.guild, ctx.author, ctx.author, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, tid)
        ok = __dd.Embed(title="ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ä½œæˆ", description="ã‚¿ã‚¹ã‚¯ä½œæˆæ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼", color=__dd.Color.green())
        ok.add_field(name="ã‚¿ã‚¹ã‚¯ID", value=str(tid), inline=True)
        ok.add_field(name="æœŸæ—¥", value=due.strftime('%Y/%m/%d %H:%M'), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[FIX_BLOCK] test error: {e}", exc_info=True)
        await ctx.send("âŒ ãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /FIX_BLOCK ====






# ==== LINK_RENAME (handle_task_actionå†…ã§å¼·åˆ¶é€£å‹•) ====
import sqlite3 as _sq, discord as _dd, asyncio as _aio, re as _re

def _link_emoji(status):
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(status,"âšª")

def _link_desired(action):
    return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
            "abandon_task":"abandoned","decline_task":"declined"}.get(action)

async def _link_find_or_save_thread(interaction, task_id, task_name):
    # 1) DBã« thread_id ãŒã‚ã‚Œã°ãã‚Œã‚’ä½¿ã†
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        row=c.fetchone(); c.connection.close()
    except Exception: row=None
    th=None
    if row and row[0]:
        th = interaction.client.get_channel(row[0])
        if not isinstance(th,_dd.Thread):
            try: th = await interaction.client.fetch_channel(row[0])
            except Exception: th=None
        if isinstance(th,_dd.Thread):
            return th

    # 2) æ–‡è„ˆã‹ã‚‰ç‰¹å®šï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰å†…â†’channelã€è¦ªâ†’message.threadã€ãªã‘ã‚Œã°è¦ªchã®threadsï¼‰
    msg=interaction.message
    th = msg.channel if isinstance(msg.channel,_dd.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_dd.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None

    # 3) è¦‹ã¤ã‹ã£ãŸã‚‰DBã«ä¿å­˜
    if isinstance(th,_dd.Thread):
        try:
            conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
            conn.commit(); conn.close()
        except Exception: pass
    return th

# æ—¢å­˜ã® handle_task_action ã‚’ä¸Šæ›¸ãï¼šå…ƒã®å‡¦ç†â†’é€£å‹•ãƒªãƒãƒ¼ãƒ ã®é †ã§å®Ÿæ–½
__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    # 1) ã¾ãšå…ƒã®å‡¦ç†ã‚’å®Ÿè¡Œï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°ãƒ»Embedåˆ‡æ›¿ãªã©ï¼‰
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    # 2) ã‚¢ã‚¯ã‚·ãƒ§ãƒ³â†’ç›®æ¨™ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
    desired = _link_desired(action)
    if not desired: 
        return

    # 3) ã‚¿ã‚¹ã‚¯åã‚’å–å¾—ï¼ˆEmbedã‚¿ã‚¤ãƒˆãƒ« or DBï¼‰
    task_name = None
    try:
        if interaction.message.embeds:
            title = (interaction.message.embeds[0].title or "").strip()
            task_name = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception:
        task_name=None
    if not task_name:
        try:
            c=_sq.connect('reminder_bot.db').cursor()
            c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            task_name = r[0] if r else None
        except Exception:
            task_name=None

    # 4) å¯¾è±¡ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç‰¹å®šï¼ˆå¿…è¦ãªã‚‰ä¿å­˜ï¼‰
    th = await _link_find_or_save_thread(interaction, task_id, task_name)
    if not isinstance(th,_dd.Thread):
        # å°‘ã—é…å»¶å¾Œã«ã‚‚ã†ä¸€åº¦ï¼ˆä½œæˆç›´å¾Œã®ç«¶åˆå›é¿ï¼‰
        await _aio.sleep(0.25)
        th = await _link_find_or_save_thread(interaction, task_id, task_name)
        if not isinstance(th,_dd.Thread):
            return

    # 5) æ¨©é™ãƒã‚§ãƒƒã‚¯
    me = interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p = th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    # 6) ã‚¹ãƒ¬ãƒƒãƒ‰åã®å…ˆé ­çµµæ–‡å­—ã‚’å·®ã—æ›¿ãˆï¼ˆğŸŸ¥/ğŸŸ¨/ğŸŸ©/âš ï¸/âŒï¼‰
    cur = th.name or ""
    em  = _link_emoji(desired)
    for e in ["ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"]:
        if cur.startswith(e):
            new = em + cur[len(e):]
            break
    else:
        new = f"{em} {cur}"
    new=new.lstrip()

    if new != cur:
        await th.edit(name=new)
        logger.info(f"[link-rename] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link-rename] no change: '{cur}' (action={action})")
# ==== /LINK_RENAME ====

# ==== MIN_SEND_NOTIFY (save thread_id; no TaskID in embeds) ====
import sqlite3 as _sq, datetime as _dt, discord as _dd

def _db_exec(sql, params=(), fetch=False):
    conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

# tasks.thread_id ãŒç„¡ã‘ã‚Œã°è¿½åŠ 
try:
    cols={c[1] for c in _db_exec("PRAGMA table_info(tasks)", fetch=True)}
    if 'thread_id' not in cols:
        _db_exec("ALTER TABLE tasks ADD COLUMN thread_id INTEGER")
        logger.info("[min] added thread_id")
except Exception as e:
    logger.error(f"[min] migration: {e}", exc_info=True)

async def _min_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id:int=None):
    try:
        if task_id is None:
            row=_db_exec("SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? ORDER BY created_at DESC LIMIT 1",
                         (guild.id, assignee.id, task_name), fetch=True)
            if not row: return
            task_id=row[0][0]

        ch=_dd.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow={guild.default_role:_dd.PermissionOverwrite(read_messages=False),
                    assignee:_dd.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch=await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro=_dd.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                color=_dd.Color.blue())
                await ch.send(embed=intro)
            except Exception:
                try: ch=await assignee.create_dm()
                except: return

        emb=_dd.Embed(title=f"ğŸ“‹ {task_name}",
                      description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**",
                      color=_dd.Color.gold())
        view=TaskView(task_id, assignee.id, instructor.id, "pending")
        main=await ch.send(assignee.mention, embed=emb, view=view)

        th=await main.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
        det=_dd.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_dd.Color.blue())
        det.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
        det.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
        det.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
        await th.send(embed=det, view=TaskView(task_id, assignee.id, instructor.id, "pending"))

        _db_exec("UPDATE tasks SET thread_id=?, message_id=? WHERE id=?", (th.id, main.id, task_id))
        logger.info(f"[min] saved thread_id={th.id}, message_id={main.id} task={task_id}")
    except Exception as e:
        logger.error(f"[min] send_task_notification: {e}", exc_info=True)

send_task_notification=_min_send_task_notification
# ==== /MIN_SEND_NOTIFY ====

# ==== LINK_HANDLE (single place to rename in handle_task_action) ====
import discord as _ddd, sqlite3 as _ss, asyncio as _aa

def _emoji(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def _desired(act): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
                           "abandon_task":"abandoned","decline_task":"declined"}.get(act)

def _find_or_save_thread(interaction, task_id, task_name):
    th = interaction.message.channel if isinstance(interaction.message.channel,_ddd.Thread) else getattr(interaction.message,"thread",None)
    if isinstance(th,_ddd.Thread): 
        try:
            c=_ss.connect('reminder_bot.db').cursor(); c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
            c.connection.commit(); c.connection.close()
        except Exception: pass
        return th
    try:
        for t in getattr(interaction.message.channel,"threads",[]):
            if task_name and task_name in (t.name or ""): 
                try:
                    c=_ss.connect('reminder_bot.db').cursor(); c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (t.id, task_id))
                    c.connection.commit(); c.connection.close()
                except Exception: pass
                return t
    except Exception: pass
    return None

__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    target=_desired(action)
    if not target: return

    # ã‚¿ã‚¹ã‚¯åï¼ˆEmbed or DBï¼‰
    tname=None
    try:
        if interaction.message.embeds:
            title=(interaction.message.embeds[0].title or "").strip()
            tname = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception: pass
    if not tname:
        try:
            c=_ss.connect('reminder_bot.db').cursor(); c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            tname=r[0] if r else None
        except Exception: pass

    th=_find_or_save_thread(interaction, task_id, tname)
    if not isinstance(th,_ddd.Thread):
        await _aa.sleep(0.25)
        th=_find_or_save_thread(interaction, task_id, tname)
        if not isinstance(th,_ddd.Thread): return

    me=interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p=th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    cur=th.name or ""
    em=_emoji(target)
    for e in ["ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"]:
        if cur.startswith(e):
            new = em + cur[len(e):]; break
    else:
        new = f"{em} {cur}"
    new=new.lstrip()

    if new != cur:
        await th.edit(name=new)
        logger.info(f"[link] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link] no change: '{cur}' (action={action})")
# ==== /LINK_HANDLE ====

# ==== MIN_SEND_NOTIFY (save thread_id; no TaskID in embeds) ====
import sqlite3 as _sq, datetime as _dt, discord as _dd

def _db_exec(sql, params=(), fetch=False):
    conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

# tasks.thread_id ãŒç„¡ã‘ã‚Œã°è¿½åŠ 
try:
    cols={c[1] for c in _db_exec("PRAGMA table_info(tasks)", fetch=True)}
    if 'thread_id' not in cols:
        _db_exec("ALTER TABLE tasks ADD COLUMN thread_id INTEGER")
        logger.info("[min] added thread_id")
except Exception as e:
    logger.error(f"[min] migration: {e}", exc_info=True)

async def _min_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id:int=None):
    try:
        if task_id is None:
            row=_db_exec("SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? ORDER BY created_at DESC LIMIT 1",
                         (guild.id, assignee.id, task_name), fetch=True)
            if not row: return
            task_id=row[0][0]

        ch=_dd.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow={guild.default_role:_dd.PermissionOverwrite(read_messages=False),
                    assignee:_dd.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch=await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro=_dd.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                color=_dd.Color.blue())
                await ch.send(embed=intro)
            except Exception:
                try: ch=await assignee.create_dm()
                except: return

        emb=_dd.Embed(title=f"ğŸ“‹ {task_name}",
                      description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**",
                      color=_dd.Color.gold())
        view=TaskView(task_id, assignee.id, instructor.id, "pending")
        main=await ch.send(assignee.mention, embed=emb, view=view)

        th=await main.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
        det=_dd.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_dd.Color.blue())
        det.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
        det.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
        det.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
        await th.send(embed=det, view=TaskView(task_id, assignee.id, instructor.id, "pending"))

        _db_exec("UPDATE tasks SET thread_id=?, message_id=? WHERE id=?", (th.id, main.id, task_id))
        logger.info(f"[min] saved thread_id={th.id}, message_id={main.id} task={task_id}")
    except Exception as e:
        logger.error(f"[min] send_task_notification: {e}", exc_info=True)

send_task_notification=_min_send_task_notification
# ==== /MIN_SEND_NOTIFY ====

# ==== LINK_HANDLE (single place to rename in handle_task_action) ====
import discord as _ddd, sqlite3 as _ss, asyncio as _aa

def _emoji(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def _desired(act): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
                           "abandon_task":"abandoned","decline_task":"declined"}.get(act)

def _find_or_save_thread(interaction, task_id, task_name):
    th = interaction.message.channel if isinstance(interaction.message.channel,_ddd.Thread) else getattr(interaction.message,"thread",None)
    if isinstance(th,_ddd.Thread): 
        try:
            c=_ss.connect('reminder_bot.db').cursor(); c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
            c.connection.commit(); c.connection.close()
        except Exception: pass
        return th
    try:
        for t in getattr(interaction.message.channel,"threads",[]):
            if task_name and task_name in (t.name or ""): 
                try:
                    c=_ss.connect('reminder_bot.db').cursor(); c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (t.id, task_id))
                    c.connection.commit(); c.connection.close()
                except Exception: pass
                return t
    except Exception: pass
    return None

__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    target=_desired(action)
    if not target: return

    # ã‚¿ã‚¹ã‚¯åï¼ˆEmbed or DBï¼‰
    tname=None
    try:
        if interaction.message.embeds:
            title=(interaction.message.embeds[0].title or "").strip()
            tname = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception: pass
    if not tname:
        try:
            c=_ss.connect('reminder_bot.db').cursor(); c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            tname=r[0] if r else None
        except Exception: pass

    th=_find_or_save_thread(interaction, task_id, tname)
    if not isinstance(th,_ddd.Thread):
        await _aa.sleep(0.25)
        th=_find_or_save_thread(interaction, task_id, tname)
        if not isinstance(th,_ddd.Thread): return

    me=interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p=th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    cur=th.name or ""
    em=_emoji(target)
    for e in ["ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"]:
        if cur.startswith(e):
            new = em + cur[len(e):]; break
    else:
        new = f"{em} {cur}"
    new=new.lstrip()

    if new != cur:
        await th.edit(name=new)
        logger.info(f"[link] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link] no change: '{cur}' (action={action})")
# ==== /LINK_HANDLE ====

# ==== CANONICAL_RENAME (single-source & debounce) ====
import discord as _d, asyncio as _a, time as _t, sqlite3 as _sq, re as _re

# 1) Thread.edit ã‚’ãƒ‡ãƒã‚¦ãƒ³ã‚¹ï¼ˆåŒä¸€ã‚¹ãƒ¬ãƒƒãƒ‰é€£ç¶š rename ã‚’ 1 å›ã«é›†ç´„ï¼‰
if not hasattr(_d.Thread, "_orig_edit"):
    _d.Thread._orig_edit = _d.Thread.edit
    _REN = {}  # tid -> {"task":Task,"name":str}
    logger.info("[agg] patch Thread.edit")

    async def _w(th:_d.Thread):
        await _a.sleep(0.25)                 # é€£ç¶šå‘¼ã³å‡ºã—ã‚’åŒæ™‚åˆ»ã«ã¾ã¨ã‚ã‚‹
        name = _REN[th.id].get("name")
        try:
            await _d.Thread._orig_edit(th, name=name)
            logger.info(f"[agg] apply name='{name}' tid={th.id}")
        except Exception as e:
            logger.warning(f"[agg] apply failed: {e}")
        finally:
            _REN[th.id]["task"]=None

    async def _edit(self:_d.Thread, *args, **kw):
        if "name" not in kw:                # åå‰ä»¥å¤–ã®ç·¨é›†ã¯ç´ é€šã—
            return await _d.Thread._orig_edit(self, *args, **kw)
        st=_REN.setdefault(self.id, {})
        st["name"]=kw["name"]
        if not st.get("task"):
            st["task"]=_a.create_task(_w(self))
        await st["task"]
        return self

    _d.Thread.edit = _edit

# 2) â€œè‰²æ›¿ãˆç³»ãƒªã‚¹ãƒŠãƒ¼â€ã‚’é™ã‹ã«ç„¡åŠ¹åŒ–ï¼ˆon_interaction ã§ rename ã ã‘ã‚’ã‚„ã‚‹ç‰©ã‚’é™¤å¤–ï¼‰
try:
    if hasattr(bot,"_listeners") and "on_interaction" in bot._listeners:
        kept=[]
        for cb in bot._listeners["on_interaction"]:
            nm=getattr(cb,"__name__","")
            if any(k in nm for k in ("rename","WRAP","LISTENER","STATE_COLOR","FINAL","RETRY","FIX")):
                logger.info(f"[mute] disable listener: {nm}")
                continue
            kept.append(cb)
        bot._listeners["on_interaction"]=kept
except Exception as e:
    logger.warning(f"[mute] skip: {e}")

# 3) handle_task_action ã®ä¸­ã§ç¢ºå®Ÿã« 1 å›ã ã‘è‰²æ›¿ãˆï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨å®Œå…¨é€£å‹•ï¼‰
def _em(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def _target(act): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted","abandon_task":"abandoned","decline_task":"declined"}.get(act)

def _get_thread_from_db(task_id):
    try:
        c=_sq.connect('reminder_bot.db').cursor(); c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        row=c.fetchone(); c.connection.close()
        return row[0] if row else None
    except Exception:
        return None

def _save_thread_id(task_id, thread_id):
    try:
        c=_sq.connect('reminder_bot.db').cursor(); c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (thread_id, task_id))
        c.connection.commit(); c.connection.close()
    except Exception: pass

async def _find_thread(inter, task_id, task_name):
    # 1) DB thread_id
    tid=_get_thread_from_db(task_id)
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,_d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,_d.Thread):
            return th
    # 2) æ–‡è„ˆï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰å†… or è¦ªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ thread / è¦ªchã®threadsï¼‰
    msg=inter.message
    th = msg.channel if isinstance(msg.channel,_d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,_d.Thread):
        _save_thread_id(task_id, th.id)
    return th

__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    tgt=_target(action)
    if not tgt: return
    # ã‚¿ã‚¹ã‚¯åï¼ˆEmbedâ†’DB ã®é †ï¼‰
    tname=None
    try:
        if interaction.message.embeds:
            title=(interaction.message.embeds[0].title or "").strip()
            tname = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception: pass
    if not tname:
        try:
            c=_sq.connect('reminder_bot.db').cursor(); c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close(); tname=r[0] if r else None
        except Exception: pass

    th=await _find_thread(interaction, task_id, tname)
    if not isinstance(th,_d.Thread): 
        logger.info("[link] no thread"); return

    me=interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p=th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)): 
            logger.info("[link] no perm"); return

    cur=th.name or ""; em=_em(tgt)
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e):
            new=em+cur[len(e):]; break
    else:
        new=f"{em} {cur}"
    new=new.lstrip()

    if new!=cur:
        await th.edit(name=new)          # â† ã“ã“ãŒé›†ç´„ã•ã‚Œã€æœ€çµ‚åã ã‘ 1 å› PATCH
        logger.info(f"[link] '{cur}' -> '{new}' ({action})")
    else:
        logger.info(f"[link] no change: '{cur}' ({action})")
# ==== /CANONICAL_RENAME ====

# ==== LINK_HANDLE (single source of rename in handle_task_action) ====
import discord as _d, sqlite3 as _sq, asyncio as _a

def _emoji(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def _target(act): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
                           "abandon_task":"abandoned","decline_task":"declined"}.get(act)

def _save_thread(task_id, tid):
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (tid, task_id))
        c.connection.commit(); c.connection.close()
    except Exception: pass

async def _find_thread(inter, task_id, task_name):
    # 1) DBã«ä¿å­˜æ¸ˆã¿ã® thread_id
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        row=c.fetchone(); c.connection.close()
        tid=row[0] if row else None
    except Exception:
        tid=None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,_d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,_d.Thread): return th

    # 2) æ–‡è„ˆã‹ã‚‰ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰å†…â†’channelã€è¦ªâ†’message.threadã€è¦ªchã®threadsï¼‰
    msg=inter.message
    th = msg.channel if isinstance(msg.channel,_d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,_d.Thread):
        _save_thread(task_id, th.id)
    return th

# å…ƒã®ãƒãƒ³ãƒ‰ãƒ©ã‚’é€€é¿ã—ã¦ä¸Šæ›¸ã
__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    tgt=_target(action)
    if not tgt: return

    # ã‚¿ã‚¹ã‚¯åï¼ˆEmbedâ†’DBï¼‰
    tname=None
    try:
        if interaction.message.embeds:
            title=(interaction.message.embeds[0].title or "").strip()
            tname = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception: pass
    if not tname:
        try:
            c=_sq.connect('reminder_bot.db').cursor(); c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            tname=r[0] if r else None
        except Exception: pass

    th=await _find_thread(interaction, task_id, tname)
    if not isinstance(th,_d.Thread):
        await _a.sleep(0.25)            # ç”Ÿæˆç›´å¾Œã®ç«¶åˆå›é¿
        th=await _find_thread(interaction, task_id, tname)
        if not isinstance(th,_d.Thread): 
            return

    me=interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p=th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    cur=th.name or ""
    em=_emoji(tgt)
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e):
            new=em+cur[len(e):]; break
    else:
        new=f"{em} {cur}"
    new=new.lstrip()

    if new!=cur:
        await th.edit(name=new)         # â† ã“ã®1å›ã ã‘ã§è‰²ã‚’åæ˜ 
        logger.info(f"[link] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link] no change: '{cur}' (action={action})")
# ==== /LINK_HANDLE ====

# ==== LINK_HANDLE_FINAL (single source of truth) ====
import discord as _d, sqlite3 as _sq, asyncio as _a

def __em(st): 
    return {"pending":"ï¿½ï¿½","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")

def __tgt(act): 
    return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
            "abandon_task":"abandoned","decline_task":"declined"}.get(act)

def __save_thread_id(task_id, tid):
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (tid, task_id))
        c.connection.commit(); c.connection.close()
    except Exception: 
        pass

def __get_thread_id(task_id):
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        r=c.fetchone(); c.connection.close()
        return r[0] if r else None
    except Exception:
        return None

async def __find_thread(inter, task_id, task_name):
    # 1) DBã® thread_id ã‚’å„ªå…ˆ
    tid=__get_thread_id(task_id)
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,_d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,_d.Thread): 
            return th
    # 2) æ–‡è„ˆã‹ã‚‰ç‰¹å®š
    msg=inter.message
    th = msg.channel if isinstance(msg.channel,_d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: 
            th=None
    if isinstance(th,_d.Thread):
        __save_thread_id(task_id, th.id)
    return th

# ç›´å‰ã®å®šç¾©ã‚’é€€é¿ã—ã€æœ€å¾Œã«ã“ã‚Œã‚’ä½¿ã‚ã›ã‚‹
__orig_handle = globals().get('handle_task_action')

async def handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status):
    # 1) ã¾ãšå…ƒã®å‡¦ç†ã‚’å®Ÿè¡Œï¼ˆDBæ›´æ–°ãƒ»Embedåˆ‡æ›¿ãªã©ï¼‰
    if callable(__orig_handle):
        await __orig_handle(interaction, action, task_id, assignee_id, instructor_id, current_status)

    target=__tgt(action)
    if not target: 
        return

    # 2) ã‚¿ã‚¹ã‚¯åï¼ˆEmbed â†’ DBã®é †ï¼‰
    task_name=None
    try:
        if interaction.message.embeds:
            title=(interaction.message.embeds[0].title or "").strip()
            task_name = title[2:].strip() if title.startswith("ğŸ“‹") else title
    except Exception:
        task_name=None
    if not task_name:
        try:
            c=_sq.connect('reminder_bot.db').cursor()
            c.execute("SELECT task_name FROM tasks WHERE id=?", (task_id,))
            r=c.fetchone(); c.connection.close()
            task_name=r[0] if r else None
        except Exception:
            task_name=None

    # 3) ã‚¹ãƒ¬ãƒƒãƒ‰ç‰¹å®šï¼ˆãªã‘ã‚Œã°å°‘ã—å¾…ã£ã¦å†æ¤œç´¢ï¼‰
    th=await __find_thread(interaction, task_id, task_name)
    if not isinstance(th,_d.Thread):
        await _a.sleep(0.25)
        th=await __find_thread(interaction, task_id, task_name)
        if not isinstance(th,_d.Thread):
            return

    # 4) æ¨©é™
    me=interaction.guild.get_member(bot.user.id) if interaction.guild else None
    if me:
        p=th.permissions_for(me)
        if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
            return

    # 5) å…ˆé ­çµµæ–‡å­—ã‚’ 1 å›ã ã‘æ›´æ–°ï¼ˆé›†ç´„ãƒ‘ãƒƒãƒãŒå…¥ã£ã¦ã„ã‚Œã°å¤šé‡å‘¼ã³å‡ºã—ã§ã‚‚1å›ã«ã¾ã¨ã¾ã‚‹ï¼‰
    cur=th.name or ""
    em=__em(target)
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e):
            new = em + cur[len(e):]; break
    else:
        new = f"{em} {cur}"
    new = new.lstrip()

    if new != cur:
        await th.edit(name=new)
        logger.info(f"[link] '{cur}' -> '{new}' (action={action}, id={task_id})")
    else:
        logger.info(f"[link] no change: '{cur}' (action={action})")
# ==== /LINK_HANDLE_FINAL ====

# ==== CANONICAL_EVENT (single on_interaction that updates status & renames thread) ====
import discord as _d, sqlite3 as _sq, asyncio as _a, re as _re

def _em(st): return {"pending":"ğŸŸ¥","accepted":"ï¿½ï¿½","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def _tgt(act): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
                       "abandon_task":"abandoned","decline_task":"declined"}.get(act)

def _save_thread_id(task_id, tid):
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("UPDATE tasks SET thread_id=? WHERE id=?", (tid, task_id))
        c.connection.commit(); c.connection.close()
    except Exception: pass

def _get_thread_id(task_id):
    try:
        c=_sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT thread_id FROM tasks WHERE id=?", (task_id,))
        r=c.fetchone(); c.connection.close()
        return r[0] if r else None
    except Exception: return None

async def _find_thread(inter, task_id, task_name):
    tid=_get_thread_id(task_id)
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,_d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,_d.Thread): return th
    msg=inter.message
    th=msg.channel if isinstance(msg.channel,_d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,_d.Thread): _save_thread_id(task_id, th.id)
    return th

# æ—¢å­˜ on_ready ã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã€ä½™åˆ†ãª on_interaction ãƒªã‚¹ãƒŠãƒ¼ã‚’ç„¡åŠ¹åŒ–â†’æ­£è¦ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²
__orig_ready = getattr(bot, "on_ready", None)

@bot.event
async def on_ready():
    if callable(__orig_ready):
        await __orig_ready()

    try:
        # æ—¢å­˜ã® on_interaction ãƒªã‚¹ãƒŠãƒ¼ã‚’å…¨å‰Šé™¤ï¼ˆã“ã®ã‚ã¨æ­£è¦ãƒªã‚¹ãƒŠãƒ¼ã‚’ 1 å€‹ã ã‘è¿½åŠ ï¼‰
        if hasattr(bot, "_listeners") and "on_interaction" in bot._listeners:
            bot._listeners["on_interaction"] = []
            logger.info("[canon] cleared existing on_interaction listeners")
    except Exception as e:
        logger.warning(f"[canon] clear failed: {e}")

    # æ­£è¦ on_interaction ã‚’ç™»éŒ²
    @bot.listen('on_interaction')
    async def __canon_interaction(inter: _d.Interaction):
        try:
            if inter.type != _d.InteractionType.component:
                return
            data=inter.data or {}
            cid = data.get('custom_id') or ''
            m=_re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
            if not m: 
                return
            action, task_id = m.group(1), int(m.group(2))

            # DBã‹ã‚‰æ‹…å½“/æŒ‡ç¤º/ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹/ã‚¿ã‚¹ã‚¯åã‚’å–å¾—
            try:
                c=_sq.connect('reminder_bot.db').cursor()
                c.execute("SELECT assignee_id,instructor_id,status,task_name FROM tasks WHERE id=?", (task_id,))
                row=c.fetchone(); c.connection.close()
            except Exception as e:
                logger.error(f"[canon] DB fetch failed: {e}", exc_info=True); return
            if not row: 
                logger.info("[canon] task not found"); return
            assignee_id, instructor_id, current_status, task_name = row

            # ã¾ãšå…ƒã® handle_task_actionï¼ˆç›´å‰ã«å®šç¾©ã•ã‚ŒãŸæœ€æ–°ç‰ˆï¼‰ã‚’å‘¼ã¶ â†’ DB/Embed/ãƒœã‚¿ãƒ³æ›´æ–°
            if "handle_task_action" in globals() and callable(globals()["handle_task_action"]):
                await globals()["handle_task_action"](inter, action, task_id, assignee_id, instructor_id, current_status)

            # æœ›ã¾ã—ã„çŠ¶æ…‹ã‚’ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰ç›´æ¥æ±ºå®šï¼ˆDBä¼æ’­å¾…ã¡ãƒ¬ãƒ¼ã‚¹ã‚’å›é¿ï¼‰
            target = _tgt(action)
            if not target: return

            # å¯¾è±¡ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç‰¹å®šï¼ˆthread_idãªã‘ã‚Œã°è£œå®Œï¼‰
            th = await _find_thread(inter, task_id, task_name)
            if not isinstance(th,_d.Thread):
                # ä½œæˆç›´å¾Œã®ç«¶åˆå›é¿
                await _a.sleep(0.25)
                th = await _find_thread(inter, task_id, task_name)
                if not isinstance(th,_d.Thread): 
                    logger.info("[canon] no thread"); return

            # æ¨©é™
            me = inter.guild.get_member(bot.user.id) if inter.guild else None
            if me:
                p=th.permissions_for(me)
                if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                    logger.info("[canon] no perm"); return

            # å…ˆé ­çµµæ–‡å­—ã‚’ 1 å›ã ã‘æ›´æ–°ï¼ˆé›†ç´„ãƒ‘ãƒƒãƒãŒå…¥ã£ã¦ã„ã‚Œã°è‡ªç„¶ã¨ 1 å›ã«çµ±åˆï¼‰
            cur = th.name or ""
            em  = _em(target)
            for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
                if cur.startswith(e):
                    new = em + cur[len(e):]; break
            else:
                new = f"{em} {cur}"
            new = new.lstrip()

            if new != cur:
                await th.edit(name=new)
                logger.info(f"[canon] '{cur}' -> '{new}' (action={action}, id={task_id})")
            else:
                logger.info(f"[canon] no change: '{cur}' (action={action})")

        except Exception as e:
            logger.error(f"[canon] failed: {e}", exc_info=True)

    logger.info("[canon] canonical on_interaction installed")
# ==== /CANONICAL_EVENT ====

# ==== CANONICAL_NO_RECURSION (single on_interaction; no call to handle_task_action) ====
import discord as _d, sqlite3 as _sq, asyncio as _a, re as _re, datetime as _dt

def _map_status(action):
    return {
        "accept_task": "accepted",
        "decline_task": "declined",
        "complete_task": "completed",
        "abandon_task": "abandoned",
        "undo_completion": "accepted",
    }.get(action)

def _emoji(st): 
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")

def _db_exec(sql, params=(), fetch=False):
    conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

def _get_task(task_id):
    rows=_db_exec("SELECT assignee_id,instructor_id,task_name,due_date,thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    return rows[0] if rows else None

async def _find_thread(inter, task_id, task_name):
    # 1) DBã®thread_id å„ªå…ˆ
    rid=_db_exec("SELECT thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    tid=rid[0][0] if rid and rid[0] and rid[0][0] else None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,_d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,_d.Thread): 
            return th
    # 2) æ–‡è„ˆã‹ã‚‰
    msg=inter.message
    th=msg.channel if isinstance(msg.channel,_d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,_d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    # 3) è¦‹ã¤ã‹ã£ãŸã‚‰ä¿å­˜
    if isinstance(th,_d.Thread):
        try: _db_exec("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        except Exception: pass
    return th

def _build_view(task_id, assignee_id, instructor_id, status):
    try:
        return TaskView(task_id, assignee_id, instructor_id, status)
    except Exception:
        return None

def _build_embed(title, due_dt, status):
    color = _d.Color.blue()
    if status=="pending": color=_d.Color.red()
    elif status=="accepted": color=_d.Color.gold()
    elif status=="completed": color=_d.Color.green()
    elif status=="abandoned": color=_d.Color.orange()
    elif status=="declined": color=_d.Color.dark_gray()

    due_str = due_dt if isinstance(due_dt,str) else (due_dt.strftime("%Y/%m/%d %H:%M") if isinstance(due_dt,_dt.datetime) else str(due_dt))
    e=_d.Embed(title=title or "ğŸ“‹ ã‚¿ã‚¹ã‚¯", description=f"**æœŸæ—¥: {due_str}**", color=color)
    # Statusè¡¨ç¤ºï¼ˆå¿…è¦ãªã‚‰ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¶³ã™ï¼‰
    e.add_field(name="Status", value=status, inline=True)
    return e

__installed=False
__orig_ready=getattr(bot,"on_ready",None)

@bot.event
async def on_ready():
    global __installed
    if callable(__orig_ready):
        await __orig_ready()
    if __installed:
        return
    __installed=True
    logger.info("[canon2] installed (no recursion)")

    @bot.listen('on_interaction')
    async def __canon2(inter:_d.Interaction):
        try:
            if inter.type != _d.InteractionType.component:
                return
            cid=(inter.data or {}).get('custom_id') or ''
            m=_re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
            if not m:
                return
            action, task_id = m.group(1), int(m.group(2))
            new_status = _map_status(action)
            if not new_status:
                return

            # 1) ç›´è¿‘ã®ã‚¿ã‚¹ã‚¯æƒ…å ±
            row = _get_task(task_id)
            if not row:
                logger.info("[canon2] task missing"); return
            assignee_id, instructor_id, task_name, due, _ = row

            # 2) DBã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’æ›´æ–°ï¼ˆã“ã®ãƒãƒ³ãƒ‰ãƒ©ãŒå˜ç‹¬ã§å®Œçµï¼‰
            _db_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status, task_id))

            # 3) Embed/ãƒœã‚¿ãƒ³ã‚’æ›´æ–°
            title = (inter.message.embeds[0].title if inter.message.embeds else f"ğŸ“‹ {task_name}") or f"ğŸ“‹ {task_name}"
            emb = _build_embed(title, due, new_status)
            view = _build_view(task_id, assignee_id, instructor_id, new_status)

            try:
                if not inter.response.is_done():
                    await inter.response.edit_message(embed=emb, view=view)
                else:
                    await inter.message.edit(embed=emb, view=view)
            except Exception:
                # å¿œç­”ãŒã™ã§ã«çµ‚ã‚ã£ã¦ã„ã‚‹å ´åˆã¯ç„¡è¦–
                pass

            # 4) ã‚¹ãƒ¬ãƒƒãƒ‰åã®çµµæ–‡å­—ã‚’å¤‰æ›´ï¼ˆ1å›ã ã‘ï¼‰
            th = await _find_thread(inter, task_id, task_name)
            if isinstance(th,_d.Thread):
                me = inter.guild.get_member(bot.user.id) if inter.guild else None
                if (not me) or getattr(th.permissions_for(me),"manage_threads",False) or getattr(th.permissions_for(me),"manage_channels",False):
                    cur = th.name or ""
                    em  = _emoji(new_status)
                    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
                        if cur.startswith(e):
                            new = em + cur[len(e):]; break
                    else:
                        new = f"{em} {cur}"
                    new = new.lstrip()
                    if new != cur:
                        await th.edit(name=new)
                        logger.info(f"[canon2] '{cur}' -> '{new}' ({action}, id={task_id})")
                    else:
                        logger.info(f"[canon2] no change: '{cur}' ({action})")
                else:
                    logger.info("[canon2] no permission to rename")
            else:
                logger.info("[canon2] thread not found")
        except Exception as e:
            logger.error(f"[canon2] failed: {e}", exc_info=True)
# ==== /CANONICAL_NO_RECURSION ====

# ==== CANONICAL2_INSTALLER (wait_until_ready; force add_listener) ====
import discord as __d, sqlite3 as __sq, asyncio as __a, re as __r, datetime as __dt

def __c2_status(action):
    return {
        "accept_task": "accepted",
        "decline_task": "declined",
        "complete_task": "completed",
        "abandon_task": "abandoned",
        "undo_completion": "accepted",
    }.get(action)

def __c2_emoji(st): 
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")

def __c2_exec(sql, params=(), fetch=False):
    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

async def __c2_find_thread(inter, task_id, task_name):
    # DBå„ªå…ˆ
    rid=__c2_exec("SELECT thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    tid=rid[0][0] if rid and rid[0] and rid[0][0] else None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,__d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,__d.Thread): return th
    # æ–‡è„ˆ
    msg=inter.message
    th=msg.channel if isinstance(msg.channel,__d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,__d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,__d.Thread):
        try: __c2_exec("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        except Exception: pass
    return th

def __c2_build_embed(title, due_dt, status):
    color = __d.Color.blurple()
    if status=="pending": color=__d.Color.red()
    elif status=="accepted": color=__d.Color.gold()
    elif status=="completed": color=__d.Color.green()
    elif status=="abandoned": color=__d.Color.orange()
    elif status=="declined": color=__d.Color.dark_gray()
    due_str = due_dt if isinstance(due_dt,str) else (due_dt.strftime("%Y/%m/%d %H:%M") if isinstance(due_dt,__dt.datetime) else str(due_dt))
    e=__d.Embed(title=title, description=f"**æœŸæ—¥: {due_str}**", color=color)
    e.add_field(name="Status", value=status, inline=True)
    return e

async def __canon2_handler(inter: __d.Interaction):
    try:
        if inter.type != __d.InteractionType.component:
            return
        cid=(inter.data or {}).get('custom_id') or ''
        m=__r.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m: return
        action, task_id = m.group(1), int(m.group(2))
        new_status = __c2_status(action)
        if not new_status: return

        # ç›´è¿‘ã‚¿ã‚¹ã‚¯æƒ…å ±
        row=__c2_exec("SELECT assignee_id,instructor_id,task_name,due_date FROM tasks WHERE id=?", (task_id,), fetch=True)
        if not row: 
            logger.info("[canon2] task missing"); return
        assignee_id, instructor_id, task_name, due = row[0]

        # DBã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å½“ãƒãƒ³ãƒ‰ãƒ©ã§æ›´æ–°ï¼ˆå†å¸°ã•ã›ãªã„ï¼‰
        __c2_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status, task_id))

        # è¡¨ç¤ºæ›´æ–°ï¼ˆEmbed/ãƒœã‚¿ãƒ³ï¼‰
        title=(inter.message.embeds[0].title if inter.message.embeds else f"ğŸ“‹ {task_name}") or f"ğŸ“‹ {task_name}"
        emb=__c2_build_embed(title, due, new_status)
        try:
            view=TaskView(task_id, assignee_id, instructor_id, new_status)
        except Exception:
            view=None

        try:
            if not inter.response.is_done():
                await inter.response.edit_message(embed=emb, view=view)
            else:
                await inter.message.edit(embed=emb, view=view)
        except Exception:
            pass

        # ã‚¹ãƒ¬ãƒƒãƒ‰åã®çµµæ–‡å­—ã‚’ 1 å›ã ã‘å¤‰æ›´
        th=await __c2_find_thread(inter, task_id, task_name)
        if isinstance(th,__d.Thread):
            me=inter.guild.get_member(bot.user.id) if inter.guild else None
            if (not me) or getattr(th.permissions_for(me),"manage_threads",False) or getattr(th.permissions_for(me),"manage_channels",False):
                cur=th.name or ""; em=__c2_emoji(new_status)
                for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
                    if cur.startswith(e): new=em+cur[len(e):]; break
                else: new=f"{em} {cur}"
                new=new.lstrip()
                if new!=cur:
                    await th.edit(name=new)
                    logger.info(f"[canon2] '{cur}' -> '{new}' (action={action}, id={task_id})")
                else:
                    logger.info(f"[canon2] no change: '{cur}' (action={action})")
            else:
                logger.info("[canon2] no permission to rename")
        else:
            logger.info("[canon2] thread not found")
    except Exception as e:
        logger.error(f"[canon2] failed: {e}", exc_info=True)

async def __canon2_install():
    await bot.wait_until_ready()
    try:
        # æ—¢å­˜ã® on_interaction ã‚’å…¨ã¦æ¶ˆã—ã¦ã€1 æœ¬ã ã‘ç™»éŒ²
        if hasattr(bot,"_listeners"):
            bot._listeners["on_interaction"]= []
    except Exception:
        pass
    bot.add_listener(__canon2_handler, "on_interaction")
    logger.info("[canon2] installed via wait_until_ready")

try:
    bot.loop.create_task(__canon2_install())
except Exception as e:
    logger.error(f"[canon2] schedule failed: {e}", exc_info=True)
# ==== /CANONICAL2_INSTALLER ====

# ==== C2_FORCE (pre-run, rename-only listener) ====
import discord as __d, sqlite3 as __sq, re as __re, asyncio as __a

def __c2_emoji(status): 
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(status,"âšª")

def __c2_target(action):
    return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted",
            "abandon_task":"abandoned","decline_task":"declined"}.get(action)

def __c2_exec(sql, params=(), fetch=False):
    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

async def __c2_find_thread(inter, task_id, task_name):
    # DBã® thread_id å„ªå…ˆ
    rid=__c2_exec("SELECT thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    tid=rid[0][0] if rid and rid[0] and rid[0][0] else None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,__d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,__d.Thread): 
            return th
    # æ–‡è„ˆã‹ã‚‰
    msg=inter.message
    th=msg.channel if isinstance(msg.channel,__d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,__d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    # è¦‹ã¤ã‹ã£ãŸã‚‰ä¿å­˜
    if isinstance(th,__d.Thread):
        try: __c2_exec("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        except Exception: pass
    return th

async def __c2_handler(inter: __d.Interaction):
    try:
        if inter.type != __d.InteractionType.component:
            return
        cid=(inter.data or {}).get('custom_id') or ''
        m=__re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m: return
        action, task_id = m.group(1), int(m.group(2))
        target = __c2_target(action)
        if not target: return

        # ã‚¿ã‚¹ã‚¯åï¼ˆEmbedã‹ã‚‰å–å¾—ã€ãªã‘ã‚Œã°DBï¼‰
        name=None
        try:
            if inter.message.embeds:
                title=(inter.message.embeds[0].title or "").strip()
                name = title[2:].strip() if title.startswith("ğŸ“‹") else title
        except Exception: pass
        if not name:
            rows=__c2_exec("SELECT task_name FROM tasks WHERE id=?", (task_id,), fetch=True)
            name = rows[0][0] if rows else None

        # å…ƒå‡¦ç†ãŒEmbedæ›´æ–°ç­‰ã‚’çµ‚ãˆã‚‹ã¾ã§è»½ãå¾…ã¤
        await __a.sleep(0.25)

        th=await __c2_find_thread(inter, task_id, name)
        if not isinstance(th,__d.Thread):
            return

        me = inter.guild.get_member(bot.user.id) if inter.guild else None
        if me:
            p=th.permissions_for(me)
            if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                return

        cur=th.name or ""; em=__c2_emoji(target)
        # å…ˆé ­ã®çµµæ–‡å­—ã‚’ç½®æ›ï¼ä»˜ä¸
        for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
            if cur.startswith(e):
                new=em+cur[len(e):]; break
        else:
            new=f"{em} {cur}"
        new=new.lstrip()

        if new!=cur:
            await th.edit(name=new)    # Thread.edit ã¯é›†ç´„ãƒ‘ãƒƒãƒã§1å›ã«çµ±åˆã•ã‚Œã‚‹
            logger.info(f"[c2] '{cur}' -> '{new}' (action={action}, id={task_id})")
        else:
            logger.info(f"[c2] no change: '{cur}' (action={action})")
    except Exception as e:
        logger.error(f"[c2] failed: {e}", exc_info=True)

# æ—¢å­˜ãƒªã‚¹ãƒŠãƒ¼ã¯è§¦ã‚‰ãšã€renameå°‚ç”¨ã®ãƒãƒ³ãƒ‰ãƒ©ã‚’â€œå‰ã‚‚ã£ã¦â€ç™»éŒ²
bot.add_listener(__c2_handler, "on_interaction")
logger.info("[c2] rename-only handler added pre-run")
# ==== /C2_FORCE ====

# ==== RENAME_AGG_COOLDOWN (debounce + cooldown for Thread.edit) ====
import discord as __d, asyncio as __aio, time as __time, logging as __logging
__log = __logging.getLogger(__name__)

# ã™ã§ã« _orig_edit ãŒç„¡ã‘ã‚Œã°é€€é¿
if not hasattr(__d.Thread, "_orig_edit"):
    __d.Thread._orig_edit = __d.Thread.edit

# çŠ¶æ…‹: tid -> {desired:str, task:Task|None, last:float}
__REN_STATE = {}
__COOLDOWN_SEC = 2.5  # ã“ã®ç§’æ•°ä»¥å†…ã®é€£ç¶š rename ã¯æ¨ã¦ã‚‹

async def __ren_worker(th: __d.Thread):
    st = __REN_STATE.setdefault(th.id, {})
    # é€£ç¶šå‘¼ã³å‡ºã—ã‚’åŒæ™‚åˆ»ã«ã¾ã¨ã‚ã‚‹
    await __aio.sleep(0.20)
    name = st.get("desired")
    # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³: ç›´è¿‘ã®é©ç”¨ã‹ã‚‰ä¸€å®šæ™‚é–“æœªæº€ãªã‚‰æ¨ã¦ã‚‹
    last = st.get("last", 0.0)
    if __time.monotonic() - last < __COOLDOWN_SEC:
        st["task"] = None
        return
    try:
        await __d.Thread._orig_edit(th, name=name)
        st["last"] = __time.monotonic()
        __log.info(f"[agg] apply name='{name}' tid={th.id}")
    except Exception as e:
        __log.warning(f"[agg] apply failed: {e}")
    finally:
        st["task"] = None

async def __patched_edit(self: __d.Thread, *args, **kw):
    # åå‰ä»¥å¤–ã®ç·¨é›†ã¯ç´ é€šã—
    if "name" not in kw:
        return await __d.Thread._orig_edit(self, *args, **kw)

    st = __REN_STATE.setdefault(self.id, {})
    st["desired"] = kw["name"]

    # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰å³ã‚¹ã‚­ãƒƒãƒ—ï¼ˆdesired ã¯æœ€æ–°ã«æ®‹ã™ï¼‰
    last = st.get("last", 0.0)
    if __time.monotonic() - last < __COOLDOWN_SEC:
        return self

    # å®Ÿè¡Œä¸­ã‚¿ã‚¹ã‚¯ãŒç„¡ã‘ã‚Œã°èµ·å‹•ã€ã‚ã‚Œã°åˆæµ
    if not st.get("task"):
        st["task"] = __aio.create_task(__ren_worker(self))
    await st["task"]
    return self

__d.Thread.edit = __patched_edit
# ==== /RENAME_AGG_COOLDOWN ====

# ==== RENAME_AGG_COOLDOWN_V2 (debounce + cooldown + applied-name dedupe) ====
import discord as _d, asyncio as _a, time as _t, logging as _lg
_log=_lg.getLogger(__name__)

# æ—¢ã«é€€é¿ã—ã¦ã„ãªã‘ã‚Œã°ä¿å­˜
if not hasattr(_d.Thread,'_orig_edit'):
    _d.Thread._orig_edit = _d.Thread.edit

_STATE = {}           # tid -> {"desired":str, "applied":str, "last":float, "task":Task|None}
_COOLDOWN = 4.0       # åŒä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ã®é€£ç¶š rename ã¯ã“ã®ç§’æ•°ä»¥å†…ãªã‚‰æ¨ã¦ã‚‹
_DEBOUNCE  = 0.20     # å‘¼ã³å‡ºã—ã‚’ã¾ã¨ã‚ã‚‹ãŸã‚ã®å¾…ã¡

async def _worker(th:_d.Thread):
    st=_STATE.setdefault(th.id,{})
    await _a.sleep(_DEBOUNCE)
    desired = st.get("desired")
    last    = st.get("last", 0.0)
    applied = st.get("applied")

    # ç›´å‰ã¨åŒã˜å¸Œæœ›åãªã‚‰æ¨ã¦ã‚‹
    if desired and applied and desired == applied:
        st["task"]=None; return
    # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰æ¨ã¦ã‚‹
    if _t.monotonic() - last < _COOLDOWN:
        st["task"]=None; return

    try:
        await _d.Thread._orig_edit(th, name=desired)
        st["last"]    = _t.monotonic()
        st["applied"] = desired
        _log.info(f"[agg] apply name='{desired}' tid={th.id}")
    except Exception as e:
        _log.warning(f"[agg] apply failed: {e}")
    finally:
        st["task"]=None

async def _patched_edit(self:_d.Thread,*args,**kw):
    # åå‰ä»¥å¤–ã®ç·¨é›†ã¯ç´ é€šã—
    if "name" not in kw:
        return await _d.Thread._orig_edit(self,*args,**kw)

    st=_STATE.setdefault(self.id,{})
    st["desired"] = kw["name"]

    # ç›´å‰ã«é©ç”¨æ¸ˆã¿ã®åå‰ã¨åŒã˜ï¼†ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰å³ã‚¹ã‚­ãƒƒãƒ—
    last    = st.get("last",0.0)
    applied = st.get("applied")
    if applied and kw["name"] == applied and _t.monotonic() - last < _COOLDOWN:
        return self

    # ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒç„¡ã‘ã‚Œã°èµ·å‹•ã€ã‚ã‚Œã°åˆæµï¼ˆ1å›ã«é›†ç´„ï¼‰
    if not st.get("task"):
        st["task"]=_a.create_task(_worker(self))
    await st["task"]
    return self

_d.Thread.edit = _patched_edit
# ==== /RENAME_AGG_COOLDOWN_V2 ====

# ==== RENAME_AGG_COOLDOWN_V2 (debounce + cooldown + applied-name dedupe) ====
import discord as _d, asyncio as _a, time as _t, logging as _lg
_log=_lg.getLogger(__name__)

# æ—¢ã«é€€é¿ã—ã¦ã„ãªã‘ã‚Œã°ä¿å­˜
if not hasattr(_d.Thread,'_orig_edit'):
    _d.Thread._orig_edit = _d.Thread.edit

_STATE = {}           # tid -> {"desired":str, "applied":str, "last":float, "task":Task|None}
_COOLDOWN = 4.0       # åŒä¸€ã‚¹ãƒ¬ãƒƒãƒ‰ã®é€£ç¶š rename ã¯ã“ã®ç§’æ•°ä»¥å†…ãªã‚‰æ¨ã¦ã‚‹
_DEBOUNCE  = 0.20     # å‘¼ã³å‡ºã—ã‚’ã¾ã¨ã‚ã‚‹ãŸã‚ã®å¾…ã¡

async def _worker(th:_d.Thread):
    st=_STATE.setdefault(th.id,{})
    await _a.sleep(_DEBOUNCE)
    desired = st.get("desired")
    last    = st.get("last", 0.0)
    applied = st.get("applied")

    # ç›´å‰ã¨åŒã˜å¸Œæœ›åãªã‚‰æ¨ã¦ã‚‹
    if desired and applied and desired == applied:
        st["task"]=None; return
    # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰æ¨ã¦ã‚‹
    if _t.monotonic() - last < _COOLDOWN:
        st["task"]=None; return

    try:
        await _d.Thread._orig_edit(th, name=desired)
        st["last"]    = _t.monotonic()
        st["applied"] = desired
        _log.info(f"[agg] apply name='{desired}' tid={th.id}")
    except Exception as e:
        _log.warning(f"[agg] apply failed: {e}")
    finally:
        st["task"]=None

async def _patched_edit(self:_d.Thread,*args,**kw):
    # åå‰ä»¥å¤–ã®ç·¨é›†ã¯ç´ é€šã—
    if "name" not in kw:
        return await _d.Thread._orig_edit(self,*args,**kw)

    st=_STATE.setdefault(self.id,{})
    st["desired"] = kw["name"]

    # ç›´å‰ã«é©ç”¨æ¸ˆã¿ã®åå‰ã¨åŒã˜ï¼†ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰å³ã‚¹ã‚­ãƒƒãƒ—
    last    = st.get("last",0.0)
    applied = st.get("applied")
    if applied and kw["name"] == applied and _t.monotonic() - last < _COOLDOWN:
        return self

    # ãƒ¯ãƒ¼ã‚«ãƒ¼ãŒç„¡ã‘ã‚Œã°èµ·å‹•ã€ã‚ã‚Œã°åˆæµï¼ˆ1å›ã«é›†ç´„ï¼‰
    if not st.get("task"):
        st["task"]=_a.create_task(_worker(self))
    await st["task"]
    return self

_d.Thread.edit = _patched_edit
# ==== /RENAME_AGG_COOLDOWN_V2 ====

# ==== SETUP_HOOK_RENAME_ONLY (no recursion / no loop attribute) ====
import discord as __d, sqlite3 as __sq, re as __re, asyncio as __a

def __em(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def __tgt(ac): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted","abandon_task":"abandoned","decline_task":"declined"}.get(ac)

def __q(sql, params=(), fetch=False):
    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params); rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

async def __find_thread(inter, task_id, task_name):
    # DBã® thread_id å„ªå…ˆ
    row=__q("SELECT thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    tid=row[0][0] if row and row[0] and row[0][0] else None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,__d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,__d.Thread): return th
    # æ–‡è„ˆã‹ã‚‰
    msg=inter.message
    th = msg.channel if isinstance(msg.channel,__d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,__d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,__d.Thread):
        try: __q("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        except Exception: pass
    return th

async def __rename_only_handler(inter: __d.Interaction):
    try:
        if inter.type != __d.InteractionType.component:
            return
        cid=(inter.data or {}).get('custom_id') or ''
        m=__re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m: return
        action, task_id = m.group(1), int(m.group(2))
        target = __tgt(action)
        if not target: return

        # ã‚¿ã‚¹ã‚¯åï¼ˆEmbedâ†’DBï¼‰
        name=None
        try:
            if inter.message.embeds:
                title=(inter.message.embeds[0].title or "").strip()
                name = title[2:].strip() if title.startswith("ğŸ“‹") else title
        except Exception: pass
        if not name:
            r=__q("SELECT task_name FROM tasks WHERE id=?", (task_id,), fetch=True)
            name=r[0][0] if r else None

        # å…ƒã®å‡¦ç†ï¼ˆEmbedæ›´æ–°ãªã©ï¼‰ãŒçµ‚ã‚ã‚‹ã¾ã§å°‘ã—å¾…ã¤
        await __a.sleep(0.25)

        th=await __find_thread(inter, task_id, name)
        if not isinstance(th,__d.Thread): return

        me=inter.guild.get_member(bot.user.id) if inter.guild else None
        if me:
            p=th.permissions_for(me)
            if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                return

        cur=th.name or ""; em=__em(target)
        for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
            if cur.startswith(e):
                new=em+cur[len(e):]; break
        else:
            new=f"{em} {cur}"
        new=new.lstrip()
        if new!=cur:
            await th.edit(name=new)            # â† Thread.edit ã¯æ—¢ã«é›†ç´„ãƒ‘ãƒƒãƒã§1å›ã«çµ±åˆ
            logger.info(f"[c2] '{cur}' -> '{new}' (action={action}, id={task_id})")
        else:
            logger.info(f"[c2] no change: '{cur}' (action={action})")
    except Exception as e:
        logger.error(f"[c2] failed: {e}", exc_info=True)

@bot.event
async def setup_hook():
    # ç«¶åˆã™ã‚‹ on_interaction ãƒªã‚¹ãƒŠãƒ¼ã‚’æ¶ˆã—ã¦ã€renameå°‚ç”¨ã ã‘ç™»éŒ²
    try:
        if hasattr(bot,"_listeners"):
            bot._listeners["on_interaction"]=[]
    except Exception: 
        pass
    bot.add_listener(__rename_only_handler, "on_interaction")
    logger.info("[c2] installed via setup_hook")
# ==== /SETUP_HOOK_RENAME_ONLY ====

# ==== SETUP_HOOK_RENAME_ONLY (no recursion / no loop attribute) ====
import discord as __d, sqlite3 as __sq, re as __re, asyncio as __a

def __em(st): return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st,"âšª")
def __tgt(ac): return {"accept_task":"accepted","complete_task":"completed","undo_completion":"accepted","abandon_task":"abandoned","decline_task":"declined"}.get(ac)

def __q(sql, params=(), fetch=False):
    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params); rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

async def __find_thread(inter, task_id, task_name):
    # DBã® thread_id å„ªå…ˆ
    row=__q("SELECT thread_id FROM tasks WHERE id=?", (task_id,), fetch=True)
    tid=row[0][0] if row and row[0] and row[0][0] else None
    th=None
    if tid:
        th=inter.client.get_channel(tid)
        if not isinstance(th,__d.Thread):
            try: th=await inter.client.fetch_channel(tid)
            except Exception: th=None
        if isinstance(th,__d.Thread): return th
    # æ–‡è„ˆã‹ã‚‰
    msg=inter.message
    th = msg.channel if isinstance(msg.channel,__d.Thread) else getattr(msg,"thread",None)
    if not isinstance(th,__d.Thread):
        try:
            for t in getattr(msg.channel,"threads",[]):
                if task_name and task_name in (t.name or ""):
                    th=t; break
        except Exception: th=None
    if isinstance(th,__d.Thread):
        try: __q("UPDATE tasks SET thread_id=? WHERE id=?", (th.id, task_id))
        except Exception: pass
    return th

async def __rename_only_handler(inter: __d.Interaction):
    try:
        if inter.type != __d.InteractionType.component:
            return
        cid=(inter.data or {}).get('custom_id') or ''
        m=__re.match(r'^(accept_task|decline_task|complete_task|abandon_task|undo_completion)_(\d+)$', cid)
        if not m: return
        action, task_id = m.group(1), int(m.group(2))
        target = __tgt(action)
        if not target: return

        # ã‚¿ã‚¹ã‚¯åï¼ˆEmbedâ†’DBï¼‰
        name=None
        try:
            if inter.message.embeds:
                title=(inter.message.embeds[0].title or "").strip()
                name = title[2:].strip() if title.startswith("ğŸ“‹") else title
        except Exception: pass
        if not name:
            r=__q("SELECT task_name FROM tasks WHERE id=?", (task_id,), fetch=True)
            name=r[0][0] if r else None

        # å…ƒã®å‡¦ç†ï¼ˆEmbedæ›´æ–°ãªã©ï¼‰ãŒçµ‚ã‚ã‚‹ã¾ã§å°‘ã—å¾…ã¤
        await __a.sleep(0.25)

        th=await __find_thread(inter, task_id, name)
        if not isinstance(th,__d.Thread): return

        me=inter.guild.get_member(bot.user.id) if inter.guild else None
        if me:
            p=th.permissions_for(me)
            if not (getattr(p,"manage_threads",False) or getattr(p,"manage_channels",False)):
                return

        cur=th.name or ""; em=__em(target)
        for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
            if cur.startswith(e):
                new=em+cur[len(e):]; break
        else:
            new=f"{em} {cur}"
        new=new.lstrip()
        if new!=cur:
            await th.edit(name=new)            # â† Thread.edit ã¯æ—¢ã«é›†ç´„ãƒ‘ãƒƒãƒã§1å›ã«çµ±åˆ
            logger.info(f"[c2] '{cur}' -> '{new}' (action={action}, id={task_id})")
        else:
            logger.info(f"[c2] no change: '{cur}' (action={action})")
    except Exception as e:
        logger.error(f"[c2] failed: {e}", exc_info=True)

@bot.event
async def setup_hook():
    # ç«¶åˆã™ã‚‹ on_interaction ãƒªã‚¹ãƒŠãƒ¼ã‚’æ¶ˆã—ã¦ã€renameå°‚ç”¨ã ã‘ç™»éŒ²
    try:
        if hasattr(bot,"_listeners"):
            bot._listeners["on_interaction"]=[]
    except Exception: 
        pass
    bot.add_listener(__rename_only_handler, "on_interaction")
    logger.info("[c2] installed via setup_hook")
# ==== /SETUP_HOOK_RENAME_ONLY ====


if __name__ == "__main__":
    token=os.getenv("DISCORD_BOT_TOKEN")
    if not token:
        raise SystemExit("DISCORD_BOT_TOKEN ãŒæœªè¨­å®šã§ã™ã€‚export DISCORD_BOT_TOKEN=... ã§è¨­å®šã—ã¦ãã ã•ã„ã€‚")
    bot.run(token)
# ==== HOTFIX: verbose on_command_error ====
@bot.event
async def on_command_error(ctx, error):
    try:
        logger.error(f"[CMD:{getattr(ctx.command,'name',None)}] Uncaught command error", exc_info=True)
    finally:
        try:
            await ctx.send("âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ï¼ˆè©³ç´°ã¯ãƒ­ã‚°ï¼‰")
        except Exception:
            pass
# ==== /HOTFIX ====
@bot.event
async def on_command_error(ctx, error):
    try:
        logger.error(f"[CMD:{getattr(ctx.command,'name',None)}] Uncaught command error", exc_info=True)
    finally:
        try:
            await ctx.send("âŒ ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ï¼ˆè©³ç´°ã¯ãƒ­ã‚°ï¼‰")
        except Exception:
            pass
# ==== HOTFIX (safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

# 1) DatabaseManager.add_task ã‚’å¿…ãš ID ã‚’è¿”ã™å®Ÿè£…ã«å·®ã—æ›¿ãˆ
def __fixed_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fixed_add_task)
except NameError:
    pass

# 2) send_task_notification ã‚’ 7å¼•æ•°ãƒ»task_id çœç•¥å¯ã®å®‰å…¨ç‰ˆã«å·®ã—æ›¿ãˆ
async def __fixed_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("Task not found just after insert (fallback search failed).")
                return
            task_id = row[0][0]

        ch_name = f"to-{assignee.display_name}"
        ch = _discord.utils.get(guild.channels, name=ch_name)
        if not ch:
            try:
                ow = {
                    guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                    assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True),
                }
                ch = await guild.create_text_channel(ch_name, overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro = _discord.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                       description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                       color=_discord.Color.blue())
                intro.add_field(name="æ©Ÿèƒ½", value="â€¢ ã‚¿ã‚¹ã‚¯é€šçŸ¥ã®å—ä¿¡\nâ€¢ ã‚¿ã‚¹ã‚¯ã®å—è¨—ãƒ»å®Œäº†å ±å‘Š\nâ€¢ é€²æ—çŠ¶æ³ã®ç¢ºèª", inline=False)
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"Failed to create personal channel/DM: {e}")
                    return

        embed = _discord.Embed(
            title=f"ğŸ“‹ {task_name}",
            description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**",
            color=_discord.Color.gold()
        )
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            thread = await msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
            detail = _discord.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_discord.Color.blue())
            detail.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
            detail.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
            detail.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await thread.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"__fixed_send_task_notification error: {e}", exc_info=True)

try:
    send_task_notification = __fixed_send_task_notification
except NameError:
    pass

# 3) !test ã‚’æœªå®šç¾©å¤‰æ•°ãªã—ã®å®Œæˆç‰ˆã§å†ç™»éŒ²
try:
    bot.remove_command('test')
    bot.remove_command('ãƒ†ã‚¹ãƒˆ')
except Exception:
    pass

@bot.command(name='ãƒ†ã‚¹ãƒˆ', aliases=['test'])
async def __fixed_test(ctx):
    try:
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("âŒ ã‚¿ã‚¹ã‚¯ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ï¼ˆç›´å¾Œç¢ºèªNGï¼‰")
            return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ä½œæˆ", description="ã‚¿ã‚¹ã‚¯ä½œæˆæ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼", color=_discord.Color.green())
        ok.add_field(name="ã‚¿ã‚¹ã‚¯ID", value=str(task_id), inline=True)
        ok.add_field(name="æœŸæ—¥", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"fixed test error: {e}", exc_info=True)
        await ctx.send("âŒ ãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /HOTFIX ====
# ==== HOTFIX (safe overrides) ====
import sqlite3 as _sqlite3
import datetime as _dt
import discord as _discord

# 1) DatabaseManager.add_task ã‚’å¿…ãš ID ã‚’è¿”ã™å®Ÿè£…ã«å·®ã—æ›¿ãˆ
def __fixed_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn = _sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO tasks (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id) "
        "VALUES (?, ?, ?, ?, ?, ?, ?)",
        (guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id)
    )
    tid = cur.lastrowid
    conn.commit()
    conn.close()
    return tid

try:
    DatabaseManager.add_task = staticmethod(__fixed_add_task)
except NameError:
    pass

# 2) send_task_notification ã‚’ 7å¼•æ•°ãƒ»task_id çœç•¥å¯ã®å®‰å…¨ç‰ˆã«å·®ã—æ›¿ãˆ
async def __fixed_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id: int=None):
    try:
        if task_id is None:
            row = DatabaseManager.execute_query(
                "SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? "
                "ORDER BY created_at DESC LIMIT 1",
                (guild.id, assignee.id, task_name)
            )
            if not row:
                logger.error("Task not found just after insert (fallback search failed).")
                return
            task_id = row[0][0]

        ch_name = f"to-{assignee.display_name}"
        ch = _discord.utils.get(guild.channels, name=ch_name)
        if not ch:
            try:
                ow = {
                    guild.default_role: _discord.PermissionOverwrite(read_messages=False),
                    assignee: _discord.PermissionOverwrite(read_messages=True, send_messages=True),
                }
                ch = await guild.create_text_channel(ch_name, overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro = _discord.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                       description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                       color=_discord.Color.blue())
                intro.add_field(name="æ©Ÿèƒ½", value="â€¢ ã‚¿ã‚¹ã‚¯é€šçŸ¥ã®å—ä¿¡\nâ€¢ ã‚¿ã‚¹ã‚¯ã®å—è¨—ãƒ»å®Œäº†å ±å‘Š\nâ€¢ é€²æ—çŠ¶æ³ã®ç¢ºèª", inline=False)
                await ch.send(embed=intro)
            except Exception as e:
                try:
                    ch = await assignee.create_dm()
                except:
                    logger.error(f"Failed to create personal channel/DM: {e}")
                    return

        embed = _discord.Embed(
            title=f"ğŸ“‹ {task_name}",
            description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**",
            color=_discord.Color.gold()
        )
        view = TaskView(task_id, assignee.id, instructor.id, "pending")
        msg = await ch.send(assignee.mention, embed=embed, view=view)

        try:
            thread = await msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
            detail = _discord.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_discord.Color.blue())
            detail.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
            detail.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
            detail.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await thread.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"__fixed_send_task_notification error: {e}", exc_info=True)

try:
    send_task_notification = __fixed_send_task_notification
except NameError:
    pass

# 3) !test ã‚’æœªå®šç¾©å¤‰æ•°ãªã—ã®å®Œæˆç‰ˆã§å†ç™»éŒ²
try:
    bot.remove_command('test')
    bot.remove_command('ãƒ†ã‚¹ãƒˆ')
except Exception:
    pass

@bot.command(name='ãƒ†ã‚¹ãƒˆ', aliases=['test'])
async def __fixed_test(ctx):
    try:
        due = _dt.datetime.now() + _dt.timedelta(days=1)
        due = due.replace(hour=23, minute=59, second=0, microsecond=0)
        task_id = DatabaseManager.add_task(
            guild_id=ctx.guild.id,
            instructor_id=ctx.author.id,
            assignee_id=ctx.author.id,
            task_name="ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯",
            due_date=due,
            message_id=ctx.message.id,
            channel_id=ctx.channel.id
        )
        if not DatabaseManager.execute_query("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("âŒ ã‚¿ã‚¹ã‚¯ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ï¼ˆç›´å¾Œç¢ºèªNGï¼‰")
            return
        await send_task_notification(ctx.guild, ctx.author, ctx.author, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, task_id=task_id)
        ok = _discord.Embed(title="ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ä½œæˆ", description="ã‚¿ã‚¹ã‚¯ä½œæˆæ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼", color=_discord.Color.green())
        ok.add_field(name="ã‚¿ã‚¹ã‚¯ID", value=str(task_id), inline=True)
        ok.add_field(name="æœŸæ—¥", value=due.strftime("%Y/%m/%d %H:%M"), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"fixed test error: {e}", exc_info=True)
        await ctx.send("âŒ ãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /HOTFIX ====
# ==== HOTFIX2 (DBç›´å©ããƒ»å®‰å…¨ä¸Šæ›¸ã) ====
import sqlite3 as _sqlite3, datetime as _dt, discord as _discord

def __q(sql, params=()):
    conn=_sqlite3.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute(sql, params); rows=cur.fetchall()
    conn.commit(); conn.close(); return rows

# add_task ã¨ send_task_notification ã‚’ DBç›´å©ãã§å‹•ãå½¢ã«ï¼ˆæ—¢å­˜ãŒã‚ã£ã¦ã‚‚ä¸‹ã§å†ãƒã‚¤ãƒ³ãƒ‰ï¼‰
def __fx2_add_task(guild_id, instructor_id, assignee_id, task_name, due_date, message_id, channel_id):
    conn=_sqlite3.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) VALUES (?,?,?,?,?,?,?)",
                (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id))
    tid=cur.lastrowid; conn.commit(); conn.close()
    return tid

async def __fx2_send_task_notification(guild, assignee, instructor, task_name, due_date, original_message_id, task_id=None):
    try:
        if task_id is None:
            row=__q("SELECT id FROM tasks WHERE guild_id=? AND assignee_id=? AND task_name=? ORDER BY created_at DESC LIMIT 1",
                    (guild.id, assignee.id, task_name))
            if not row: 
                logger.error("[HOTFIX2] task lookup failed"); return
            task_id=row[0][0]

        ch=_discord.utils.get(guild.channels, name=f"to-{assignee.display_name}")
        if not ch:
            try:
                ow={guild.default_role:_discord.PermissionOverwrite(read_messages=False),
                    assignee:_discord.PermissionOverwrite(read_messages=True, send_messages=True)}
                ch=await guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow, topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                intro=_discord.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                     description=f"ã“ã‚“ã«ã¡ã¯ã€{assignee.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                     color=_discord.Color.blue())
                await ch.send(embed=intro)
            except Exception:
                try: ch=await assignee.create_dm()
                except: return

        embed=_discord.Embed(title=f"ğŸ“‹ {task_name}", description=f"**æœŸæ—¥: {due_date.strftime('%Y/%m/%d %H:%M')}**", color=_discord.Color.gold())
        view=TaskView(task_id, assignee.id, instructor.id, "pending")
        msg=await ch.send(assignee.mention, embed=embed, view=view)

        try:
            th=await msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°æƒ…å ±")
            detail=_discord.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=_discord.Color.blue())
            detail.add_field(name="æŒ‡ç¤ºè€…", value=instructor.mention, inline=True)
            detail.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
            detail.add_field(name="ä½œæˆæ—¥æ™‚", value=_dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
            await th.send(embed=detail, view=TaskView(task_id, assignee.id, instructor.id, "pending"))
        except Exception:
            pass
    except Exception as e:
        logger.error(f"[HOTFIX2] send_task_notification error: {e}", exc_info=True)

# æ—¢å­˜å®Ÿè£…ã‚’ä¸Šæ›¸ã
try:
    DatabaseManager.add_task = staticmethod(__fx2_add_task)
except Exception:
    pass
send_task_notification = __fx2_send_task_notification

# !test ã‚’ DBç›´å©ãã§å†ç™»éŒ²
try:
    bot.remove_command('test'); bot.remove_command('ãƒ†ã‚¹ãƒˆ')
except Exception:
    pass

@bot.command(name='ãƒ†ã‚¹ãƒˆ', aliases=['test'])
async def __fx2_test(ctx):
    try:
        due=_dt.datetime.now()+_dt.timedelta(days=1)
        due=due.replace(hour=23,minute=59,second=0,microsecond=0)
        task_id=__fx2_add_task(ctx.guild.id, ctx.author.id, ctx.author.id, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, ctx.channel.id)
        if not __q("SELECT 1 FROM tasks WHERE id=?", (task_id,)):
            await ctx.send("âŒ ã‚¿ã‚¹ã‚¯ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚ï¼ˆç›´å¾Œç¢ºèªNGï¼‰"); return
        await __fx2_send_task_notification(ctx.guild, ctx.author, ctx.author, "ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯", due, ctx.message.id, task_id=task_id)
        ok=_discord.Embed(title="ğŸ§ª ãƒ†ã‚¹ãƒˆã‚¿ã‚¹ã‚¯ä½œæˆ", description="ã‚¿ã‚¹ã‚¯ä½œæˆæ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆãŒæˆåŠŸã—ã¾ã—ãŸï¼", color=_discord.Color.green())
        ok.add_field(name="ã‚¿ã‚¹ã‚¯ID", value=str(task_id), inline=True)
        ok.add_field(name="æœŸæ—¥", value=due.strftime('%Y/%m/%d %H:%M'), inline=True)
        await ctx.send(embed=ok)
    except Exception as e:
        logger.error(f"[HOTFIX2] test error: {e}", exc_info=True)
        await ctx.send("âŒ ãƒ†ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /HOTFIX2 ====

@bot.command(name='perms_threads')
async def perms_threads(ctx):
    m = ctx.guild.get_member(bot.user.id)
    ch = ctx.channel
    p = ch.permissions_for(m)
    lines = [
        f"manage_threads: {p.manage_threads}",
        f"create_public_threads: {p.create_public_threads}",
        f"create_private_threads: {getattr(p,'create_private_threads', 'n/a')}",
        f"send_messages_in_threads: {p.send_messages_in_threads}",
        f"manage_channels: {p.manage_channels}",
    ]
    await ctx.send("```" + "\n".join(lines) + "```")
@bot.command(name='perms_threads')
async def perms_threads(ctx):
    m = ctx.guild.get_member(bot.user.id)
    ch = ctx.channel
    p = ch.permissions_for(m)
    lines = [
        f"manage_threads: {p.manage_threads}",
        f"create_public_threads: {p.create_public_threads}",
        f"create_private_threads: {getattr(p,'create_private_threads', 'n/a')}",
        f"send_messages_in_threads: {p.send_messages_in_threads}",
        f"manage_channels: {p.manage_channels}",
    ]
    await ctx.send("```" + "\n".join(lines) + "```")

