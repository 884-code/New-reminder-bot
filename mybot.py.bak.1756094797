# ==== PRELUDE_STUBS (NameErrorå¯¾ç­–) ====
import logging, sqlite3
logger = logging.getLogger(__name__)

# init_database ãŒç„¡ã‘ã‚Œã°ã‚¹ã‚¿ãƒ–ã‚’ç”¨æ„
try:
    init_database
except NameError:
    def init_database():
        try: logger.info("[init] ã‚¹ã‚¿ãƒ–å®Ÿè¡Œï¼ˆæœ¬ä½“æœªå®šç¾©ï¼‰")
        except Exception: pass
        # DBãƒ•ã‚¡ã‚¤ãƒ«ã‚’è§¦ã£ã¦ãŠãã ã‘ï¼ˆæœ¬ä½“ãŒã‚ã‚Œã°ãã¡ã‚‰ãŒä½¿ã‚ã‚Œã‚‹ï¼‰
        conn = sqlite3.connect('reminder_bot.db'); conn.close()

# setup_roles ãŒç„¡ã‘ã‚Œã°ã‚¹ã‚¿ãƒ–ã‚’ç”¨æ„
try:
    setup_roles
except NameError:
    import discord as _d
    async def setup_roles(guild: _d.Guild):
        try: logger.info(f"[setup_roles] ã‚¹ã‚¿ãƒ–å®Ÿè¡Œï¼ˆ{getattr(guild,'name','?')}ï¼‰")
        except Exception: pass
        return None, None
# ==== /PRELUDE_STUBS ====
# -*- coding: utf-8 -*-
# mybot.py (failsafe setup edition)
import os, re, json, sqlite3, logging, asyncio
from datetime import datetime, timedelta
from typing import Optional, List

import discord
from discord import app_commands
from discord.ext import commands, tasks

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)-8s %(message)s",
    handlers=[logging.StreamHandler(), logging.FileHandler("bot.log", encoding="utf-8")]
)
logger = logging.getLogger("taskbot")

intents = discord.Intents.default()
intents.guilds = True
intents.members = True
intents.message_content = True

bot = commands.Bot(
    command_prefix=commands.when_mentioned_or("!", "ï¼", "/"),
    intents=intents,
    case_insensitive=True,
    help_command=None,
    max_messages=100,
)

DB_PATH = "reminder_bot.db"
def db_exec(q: str, params: tuple = (), fetch=False):
    conn = sqlite3.connect(DB_PATH); cur = conn.cursor()
    cur.execute(q, params); rows = cur.fetchall() if fetch else None
    conn.commit(); conn.close(); return rows

def init_db():
    db_exec("""CREATE TABLE IF NOT EXISTS admins(user_id INTEGER, guild_id INTEGER, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS instructors(user_id INTEGER, guild_id INTEGER, target_users TEXT, added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(user_id,guild_id))""")
    db_exec("""CREATE TABLE IF NOT EXISTS tasks(
        id INTEGER PRIMARY KEY AUTOINCREMENT, guild_id INTEGER, instructor_id INTEGER, assignee_id INTEGER,
        task_name TEXT, due_date TIMESTAMP, status TEXT DEFAULT 'pending',
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        message_id INTEGER, channel_id INTEGER, reminder_sent INTEGER DEFAULT 0)""")
    cols = db_exec("PRAGMA table_info(tasks)", fetch=True)
    if "reminder_sent" not in [c[1] for c in cols]:
        db_exec("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")

def is_admin(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM admins WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))
def is_instructor(uid:int,gid:int)->bool: return bool(db_exec("SELECT 1 FROM instructors WHERE user_id=? AND guild_id=?", (uid,gid), fetch=True))

def insert_task(gid:int,iid:int,aid:int,name:str,due:datetime)->int:
    db_exec("INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date) VALUES (?,?,?,?,?)", (gid,iid,aid,name,due))
    return db_exec("SELECT last_insert_rowid()", fetch=True)[0][0]

def get_task(tid:int):
    r=db_exec("SELECT * FROM tasks WHERE id=?", (tid,), fetch=True)
    return r[0] if r else None

async def ensure_mgmt(guild:discord.Guild)->Optional[discord.TextChannel]:
    for name in ("task-management","ã‚¿ã‚¹ã‚¯ç®¡ç†"):
        ch = discord.utils.get(guild.channels, name=name)
        if isinstance(ch, discord.TextChannel): return ch
    try:
        return await guild.create_text_channel("task-management", overwrites={guild.default_role: discord.PermissionOverwrite(read_messages=False)})
    except Exception as e:
        logger.error(f"mgmt create failed: {e}"); return None

async def ensure_personal(guild:discord.Guild,user:discord.Member)->Optional[discord.TextChannel]:
    name=f"to-{user.display_name}".lower().replace(" ","-")
    ch=discord.utils.get(guild.channels,name=name)
    if isinstance(ch,discord.TextChannel): return ch
    try:
        ow={guild.default_role: discord.PermissionOverwrite(read_messages=False), user: discord.PermissionOverwrite(read_messages=True, send_messages=True)}
        return await guild.create_text_channel(name=name, overwrites=ow, topic=f"{user.display_name} ã®å€‹äººã‚¿ã‚¹ã‚¯")
    except Exception as e:
        logger.error(f"personal create failed: {e}"); return None

def parse_date(s:str)->Optional[datetime]:
    now=datetime.now(); t=s.strip().lower()
    m=re.search(r'(\d{1,2}):(\d{2})$',t)
    if m: hour,minute=int(m.group(1)),int(m.group(2)); t=t[:m.start()].strip()
    else: hour,minute=23,59
    pats=[(r'^(ä»Šæ—¥|today)$',lambda m:now),(r'^(æ˜æ—¥|tomorrow)$',lambda m:now+timedelta(days=1)),
          (r'^(æ˜å¾Œæ—¥|day after tomorrow)$',lambda m:now+timedelta(days=2)),(r'^(æ˜¨æ—¥|yesterday)$',lambda m:now-timedelta(days=1)),
          (r'^(\d+)\s*(æ—¥å¾Œ|days?)$',lambda m:now+timedelta(days=int(m.group(1)))),
          (r'^(\d+)\s*(é€±é–“å¾Œ|weeks?)$',lambda m:now+timedelta(weeks=int(m.group(1)))),
          (r'^(\d+)\s*(æ™‚é–“å¾Œ|hours?)$',lambda m:now+timedelta(hours=int(m.group(1)))),
          (r'^(\d+)\s*(åˆ†å¾Œ|mins?|minutes?)$',lambda m:now+timedelta(minutes=int(m.group(1)))) ]
    for pat,fn in pats:
        mm=re.match(pat,t)
        if mm: dt=fn(mm); return dt.replace(hour=hour,minute=minute,second=0,microsecond=0)
    wk={'æœˆ':0,'ç«':1,'æ°´':2,'æœ¨':3,'é‡‘':4,'åœŸ':5,'æ—¥':6,'monday':0,'tuesday':1,'wednesday':2,'thursday':3,'friday':4,'saturday':5,'sunday':6,'mon':0,'tue':1,'wed':2,'thu':3,'fri':4,'sat':5,'sun':6}
    for name,num in wk.items():
        if name in t:
            d=num-now.weekday(); d+=7 if d<=0 else 0
            return (now+timedelta(days=d)).replace(hour=hour,minute=minute,second=0,microsecond=0)
    abs_p=[r'^(\d{4})[/-](\d{1,2})[/-](\d{1,2})$',r'^(\d{1,2})[/-](\d{1,2})$',r'^(\d{4})å¹´(\d{1,2})æœˆ(\d{1,2})æ—¥$',r'^(\d{1,2})æœˆ(\d{1,2})æ—¥$']
    for pat in abs_p:
        mm=re.match(pat,t)
        if mm:
            g=mm.groups()
            if len(g)==3 and len(g[0])==4: y,mo,d=int(g[0]),int(g[1]),int(g[2])
            elif len(g)==3: mo,d,y=int(g[0]),int(g[1]),now.year
            else: mo,d,y=int(g[0]),int(g[1]),now.year
            try: return datetime(y,mo,d,hour,minute)
            except ValueError: return None
    return None

STATUS_COLORS={'pending':discord.Color.red(),'accepted':discord.Color.gold(),'completed':discord.Color.green(),'declined':discord.Color.dark_gray(),'abandoned':discord.Color.dark_red()}
STATUS_EMOJI={'pending':'ğŸŸ¥','accepted':'ğŸŸ¨','completed':'ğŸŸ©','declined':'âšª','abandoned':'ğŸŸ«'}
STATUS_NAME={'pending':'Pending','accepted':'In Progress','completed':'Completed','declined':'Declined','abandoned':'Problem'}

def build_embed(trow,status:Optional[str]=None)->discord.Embed:
    st=status or trow[6]
    try: due_ts=int(datetime.fromisoformat(str(trow[5])).timestamp())
    except Exception: due_ts=int(datetime.strptime(str(trow[5]),"%Y-%m-%d %H:%M:%S").timestamp())
    emb=discord.Embed(title=f"ğŸ“‹ {trow[4]}", color=STATUS_COLORS.get(st, discord.Color.blurple()))
    emb.add_field(name="Due Date", value=f"<t:{due_ts}:F>", inline=True)
    emb.add_field(name="Status", value=f"{STATUS_EMOJI.get(st,'âšª')} {STATUS_NAME.get(st,st)}", inline=True)
    emb.add_field(name="Updated", value=f"<t:{int(datetime.now().timestamp())}:R>", inline=True)
    emb.set_footer(text=f"Task ID: {trow[0]}"); return emb

class TaskView(discord.ui.View):
    def __init__(self, tid:int, aid:int, iid:int, status:str):
        super().__init__(timeout=None); self.tid, self.aid, self.iid, self.status=tid,aid,iid,status; self._setup()
    def _setup(self):
        self.clear_items()
        if self.status=='pending': self.add_item(AcceptButton(self.tid)); self.add_item(DeclineButton(self.tid))
        elif self.status=='accepted': self.add_item(CompleteButton(self.tid)); self.add_item(AbandonButton(self.tid))
        elif self.status=='completed': self.add_item(UndoButton(self.tid))

class _BaseBtn(discord.ui.Button):
    def __init__(self,label,style,cid): super().__init__(label=label, style=style, custom_id=cid)
    async def _handle(self,it:discord.Interaction,new_status:str):
        t=db_exec("SELECT * FROM tasks WHERE id=?", (int(self.custom_id.split('_')[-1]),), fetch=True)
        if not t: await it.response.send_message("âŒ Task not found.", ephemeral=True); return
        t=t[0]
        if it.user.id!=t[3]: await it.response.send_message("âŒ You are not the assignee.", ephemeral=True); return
        db_exec("UPDATE tasks SET status=?, updated_at=CURRENT_TIMESTAMP WHERE id=?", (new_status,t[0]))
        t2=db_exec("SELECT * FROM tasks WHERE id=?", (t[0],), fetch=True)[0]
        await it.response.edit_message(embed=build_embed(t2,new_status), view=TaskView(t2[0],t2[3],t2[2],new_status))

class AcceptButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âœ… Accept", discord.ButtonStyle.success, f"accept_task_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')
class DeclineButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âŒ Decline", discord.ButtonStyle.danger, f"decline_task_{tid}")
    async def callback(self,it): await self._handle(it,'declined')
class CompleteButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("ğŸ“ Complete", discord.ButtonStyle.success, f"complete_task_{tid}")
    async def callback(self,it): await self._handle(it,'completed')
class AbandonButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("âš ï¸ Problem", discord.ButtonStyle.danger, f"abandon_task_{tid}")
    async def callback(self,it): await self._handle(it,'abandoned')
class UndoButton(_BaseBtn):
    def __init__(self,tid:int): super().__init__("â†©ï¸ Undo", discord.ButtonStyle.secondary, f"undo_completion_{tid}")
    async def callback(self,it): await self._handle(it,'accepted')


@bot.event
async def on_ready():
    try:
        logger.info(f'{bot.user} has landed!')
        logger.info(f"Bot is in {len(bot.guilds)} guilds")
    except Exception:
        pass
    # init_database ã¯å­˜åœ¨ã™ã‚Œã°å®Ÿè¡Œ
    try:
        init_database()
    except Exception as e:
        try: logger.warning(f"[on_ready] init_database skipped: {e}")
        except Exception: pass
    # å„ã‚®ãƒ«ãƒ‰ã§ãƒ­ãƒ¼ãƒ«ä½œæˆï¼ˆå­˜åœ¨ã™ã‚Œã°ï¼‰
    try:
        for guild in bot.guilds:
            try:
                await setup_roles(guild)
            except Exception as e:
                try: logger.warning(f"[on_ready] setup_roles skipped in {guild.id}: {e}")
                except Exception: pass
    except Exception as e:
        try: logger.warning(f"[on_ready] guild loop skipped: {e}")
        except Exception: pass

@bot.event
async def on_interaction(interaction):
    if interaction.type != discord.InteractionType.component:
        return
    
    custom_id = interaction.data.get('custom_id')
    if not custom_id:
        return
    
    parts = custom_id.split('_')
    if len(parts) < 3:
        return
    
    action = '_'.join(parts[:-1])
    try:
        task_id = int(parts[-1])
    except ValueError:
        return
    
    if action not in ['accept_task', 'decline_task', 'complete_task', 'abandon_task', 'undo_completion']:
        return
    
    try:
        task_data = DatabaseManager.execute_query(
            "SELECT assignee_id, instructor_id, status FROM tasks WHERE id = ?",
            (task_id,)
        )
        
        if not task_data:
            await interaction.response.send_message("âŒ ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
            return
        
        assignee_id, instructor_id, current_status = task_data[0]
        
        if interaction.user.id != assignee_id:
            await interaction.response.send_message("âŒ ã“ã®ã‚¿ã‚¹ã‚¯ã®æ‹…å½“è€…ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚", ephemeral=True)
            return
        
        await handle_task_action(interaction, action, task_id, assignee_id, instructor_id, current_status)
        
    except Exception as e:
        logger.error(f"Error handling persistent interaction: {e}")
        try:
            if not interaction.response.is_done():
                await interaction.response.send_message("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)
            else:
                await interaction.followup.send("âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)
        except:
            pass

# ==== ASSIGN_FALLBACK_V2 (mention or "@name" accepted, with debug) ====
import re as __re, sqlite3 as __sq, discord as __dd, datetime as __dt, asyncio as __aa

@bot.event
async def setup_hook():
    @bot.listen("on_message")
    async def __assign_fallback_v2(message: __dd.Message):
        try:
            if message.author.bot or (message.guild is None):
                return

            text = message.content.strip()

            # 1) ã€ŒãƒœãƒƒãƒˆãŒå®Ÿéš›ã®ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã€ or ã€Œ@ãƒœãƒƒãƒˆå ã§å§‹ã¾ã‚‹ã€ã‹ã‚’åˆ¤å®š
            is_real_mention = (bot.user in message.mentions)
            name_variants = [
                f"@{bot.user.display_name}",
                f"@{bot.user.name}",
            ]
            starts_with_name = any(text.startswith(v) for v in name_variants)

            if not (is_real_mention or starts_with_name):
                return  # ä»–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–

            # 2) æ‹…å½“è€…ã‚’æŠ½å‡ºï¼ˆå®Ÿãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã®ã¿æ¡ç”¨ï¼‰
            assignees = [m for m in message.mentions if m.id != (bot.user.id if is_real_mention else 0)]
            if not assignees:
                await message.reply("âŒ æŒ‡ç¤ºå¯¾è±¡ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ã€‚")
                return

            # 3) å…ˆé ­ã® @ãƒœãƒƒãƒˆ or @ãƒœãƒƒãƒˆå ã‚’å–ã‚Šé™¤ã
            if is_real_mention:
                text_wo_head = __re.sub(r'^<@!?%d>\s*' % bot.user.id, '', text).strip()
            else:
                # @ãƒªãƒã‚¤ãƒ³ãƒ€ãã‚“ / @Remind-kun ãªã©åå‰å§‹ã¾ã‚Šã‚’å–ã‚Šé™¤ã
                head = next(v for v in name_variants if text.startswith(v))
                text_wo_head = text[len(head):].strip()

            # 4) ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ï¼ˆ<@...>ï¼‰ã¯æœ¬æ–‡ã‹ã‚‰æ¶ˆã—ã¦ã‹ã‚‰ã€æ®‹ã‚Šã‚’ã€Œ,ã€ã§åˆ†å‰²
            text_wo_mentions = __re.sub(r'<@!?[0-9]+>', '', text_wo_head).strip()

            # åŠè§’/å…¨è§’ã‚«ãƒ³ãƒã©ã¡ã‚‰ã§ã‚‚æœ€åˆã®ã‚«ãƒ³ãƒã‚’è¦‹ã¤ã‘ã‚‹
            m1 = __re.search(r'[ï¼Œ,]', text_wo_mentions)
            if not m1:
                await message.reply("âŒ å½¢å¼: `@bot @ãƒ¦ãƒ¼ã‚¶ãƒ¼, æœŸæ—¥, ã‚¿ã‚¹ã‚¯å`ï¼ˆåŠè§’`,`ã‚’2ã¤ï¼‰")
                return

            rest = text_wo_mentions[m1.end():].strip()
            parts = [p.strip() for p in __re.split(r'[ï¼Œ,]', rest, maxsplit=1)]
            if len(parts) < 2:
                await message.reply("âŒ å½¢å¼: `@bot @ãƒ¦ãƒ¼ã‚¶ãƒ¼, æœŸæ—¥, ã‚¿ã‚¹ã‚¯å`")
                return

            due_str, task_name = parts[0], parts[1]
            if not task_name:
                await message.reply("âŒ ã‚¿ã‚¹ã‚¯åãŒç©ºã§ã™ã€‚")
                return

            # 5) æœŸæ—¥ãƒ‘ãƒ¼ã‚¹ï¼ˆæ—¢å­˜ã® parse_date ã‚’ä½¿ç”¨ï¼‰
            try:
                due_dt = parse_date(due_str)
            except Exception:
                due_dt = None
            if not due_dt:
                await message.reply("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ä¾‹: æ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/08/23 09:00")
                return

            # 6) è¿½åŠ  & å€‹äººCHé€šçŸ¥ï¼ˆthread_id ã‚‚ä¿å­˜ï¼‰
            created = 0
            for target in assignees:
                # DB INSERTï¼ˆåŒä¸€æ¥ç¶šã§ lastrowid å–å¾—ï¼‰
                try:
                    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                    cur.execute(
                        "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                        "VALUES (?,?,?,?,?,?,?)",
                        (message.guild.id, message.author.id, target.id, task_name, due_dt, message.id, message.channel.id)
                    )
                    tid = cur.lastrowid
                    conn.commit(); conn.close()
                except Exception as e:
                    try: conn.close()
                    except: pass
                    await message.reply(f"âŒ {target.display_name}: DBã‚¨ãƒ©ãƒ¼")
                    continue

                ch_name = f"to-{target.display_name}"
                ch = __dd.utils.get(message.guild.channels, name=ch_name)
                if not ch:
                    try:
                        ow = {
                            message.guild.default_role: __dd.PermissionOverwrite(read_messages=False),
                            target: __dd.PermissionOverwrite(read_messages=True, send_messages=True)
                        }
                        ch = await message.guild.create_text_channel(ch_name, overwrites=ow, topic=f"{target.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                        intro = __dd.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                           description=f"ã“ã‚“ã«ã¡ã¯ã€{target.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                           color=__dd.Color.blue())
                        await ch.send(embed=intro)
                    except Exception:
                        try: ch = await target.create_dm()
                        except Exception: ch = None

                if ch:
                    emb = __dd.Embed(title=f"ğŸ“‹ {task_name}",
                                     description=f"**æœŸæ—¥: {due_dt.strftime('%Y/%m/%d %H:%M')}**",
                                     color=__dd.Color.gold())
                    try:
                        view = TaskView(tid, target.id, message.author.id, "pending")
                    except Exception:
                        view = None

                    try:
                        main_msg = await ch.send(target.mention, embed=emb, view=view)
                        try:
                            th = await main_msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°")
                            det = __dd.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=__dd.Color.blue())
                            det.add_field(name="æŒ‡ç¤ºè€…", value=message.author.mention, inline=True)
                            det.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
                            det.add_field(name="ä½œæˆæ—¥æ™‚", value=__dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
                            if view is not None:
                                await th.send(embed=det, view=TaskView(tid, target.id, message.author.id, "pending"))
                            else:
                                await th.send(embed=det)
                            # ä¿å­˜
                            try:
                                conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                                cur.execute("UPDATE tasks SET thread_id=?, message_id=? WHERE id=?", (th.id, main_msg.id, tid))
                                conn.commit(); conn.close()
                            except Exception:
                                pass
                        except Exception:
                            pass
                    except Exception:
                        pass

                created += 1

            await message.reply(f"âœ… {created}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã—ã¾ã—ãŸã€‚" if created else "âŒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
        except Exception as e:
            try:
                await message.reply(f"âŒ è§£æä¸­ã‚¨ãƒ©ãƒ¼: {e}")
            except Exception:
                pass
    logger.info("[assign] fallback_v2 installed via setup_hook")
# ==== /ASSIGN_FALLBACK_V2 ====

# ==== ASSIGN_FALLBACK_V2 (mention or "@name" accepted, with debug) ====
import re as __re, sqlite3 as __sq, discord as __dd, datetime as __dt, asyncio as __aa

@bot.event
async def setup_hook():
    @bot.listen("on_message")
    async def __assign_fallback_v2(message: __dd.Message):
        try:
            if message.author.bot or (message.guild is None):
                return

            text = message.content.strip()

            # 1) ã€ŒãƒœãƒƒãƒˆãŒå®Ÿéš›ã®ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã€ or ã€Œ@ãƒœãƒƒãƒˆå ã§å§‹ã¾ã‚‹ã€ã‹ã‚’åˆ¤å®š
            is_real_mention = (bot.user in message.mentions)
            name_variants = [
                f"@{bot.user.display_name}",
                f"@{bot.user.name}",
            ]
            starts_with_name = any(text.startswith(v) for v in name_variants)

            if not (is_real_mention or starts_with_name):
                return  # ä»–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯ç„¡è¦–

            # 2) æ‹…å½“è€…ã‚’æŠ½å‡ºï¼ˆå®Ÿãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã®ã¿æ¡ç”¨ï¼‰
            assignees = [m for m in message.mentions if m.id != (bot.user.id if is_real_mention else 0)]
            if not assignees:
                await message.reply("âŒ æŒ‡ç¤ºå¯¾è±¡ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã—ã¦ãã ã•ã„ã€‚")
                return

            # 3) å…ˆé ­ã® @ãƒœãƒƒãƒˆ or @ãƒœãƒƒãƒˆå ã‚’å–ã‚Šé™¤ã
            if is_real_mention:
                text_wo_head = __re.sub(r'^<@!?%d>\s*' % bot.user.id, '', text).strip()
            else:
                # @ãƒªãƒã‚¤ãƒ³ãƒ€ãã‚“ / @Remind-kun ãªã©åå‰å§‹ã¾ã‚Šã‚’å–ã‚Šé™¤ã
                head = next(v for v in name_variants if text.startswith(v))
                text_wo_head = text[len(head):].strip()

            # 4) ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ï¼ˆ<@...>ï¼‰ã¯æœ¬æ–‡ã‹ã‚‰æ¶ˆã—ã¦ã‹ã‚‰ã€æ®‹ã‚Šã‚’ã€Œ,ã€ã§åˆ†å‰²
            text_wo_mentions = __re.sub(r'<@!?[0-9]+>', '', text_wo_head).strip()

            # åŠè§’/å…¨è§’ã‚«ãƒ³ãƒã©ã¡ã‚‰ã§ã‚‚æœ€åˆã®ã‚«ãƒ³ãƒã‚’è¦‹ã¤ã‘ã‚‹
            m1 = __re.search(r'[ï¼Œ,]', text_wo_mentions)
            if not m1:
                await message.reply("âŒ å½¢å¼: `@bot @ãƒ¦ãƒ¼ã‚¶ãƒ¼, æœŸæ—¥, ã‚¿ã‚¹ã‚¯å`ï¼ˆåŠè§’`,`ã‚’2ã¤ï¼‰")
                return

            rest = text_wo_mentions[m1.end():].strip()
            parts = [p.strip() for p in __re.split(r'[ï¼Œ,]', rest, maxsplit=1)]
            if len(parts) < 2:
                await message.reply("âŒ å½¢å¼: `@bot @ãƒ¦ãƒ¼ã‚¶ãƒ¼, æœŸæ—¥, ã‚¿ã‚¹ã‚¯å`")
                return

            due_str, task_name = parts[0], parts[1]
            if not task_name:
                await message.reply("âŒ ã‚¿ã‚¹ã‚¯åãŒç©ºã§ã™ã€‚")
                return

            # 5) æœŸæ—¥ãƒ‘ãƒ¼ã‚¹ï¼ˆæ—¢å­˜ã® parse_date ã‚’ä½¿ç”¨ï¼‰
            try:
                due_dt = parse_date(due_str)
            except Exception:
                due_dt = None
            if not due_dt:
                await message.reply("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ä¾‹: æ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/08/23 09:00")
                return

            # 6) è¿½åŠ  & å€‹äººCHé€šçŸ¥ï¼ˆthread_id ã‚‚ä¿å­˜ï¼‰
            created = 0
            for target in assignees:
                # DB INSERTï¼ˆåŒä¸€æ¥ç¶šã§ lastrowid å–å¾—ï¼‰
                try:
                    conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                    cur.execute(
                        "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                        "VALUES (?,?,?,?,?,?,?)",
                        (message.guild.id, message.author.id, target.id, task_name, due_dt, message.id, message.channel.id)
                    )
                    tid = cur.lastrowid
                    conn.commit(); conn.close()
                except Exception as e:
                    try: conn.close()
                    except: pass
                    await message.reply(f"âŒ {target.display_name}: DBã‚¨ãƒ©ãƒ¼")
                    continue

                ch_name = f"to-{target.display_name}"
                ch = __dd.utils.get(message.guild.channels, name=ch_name)
                if not ch:
                    try:
                        ow = {
                            message.guild.default_role: __dd.PermissionOverwrite(read_messages=False),
                            target: __dd.PermissionOverwrite(read_messages=True, send_messages=True)
                        }
                        ch = await message.guild.create_text_channel(ch_name, overwrites=ow, topic=f"{target.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                        intro = __dd.Embed(title="ğŸ“‹ å€‹äººã‚¿ã‚¹ã‚¯ãƒãƒ£ãƒ³ãƒãƒ«",
                                           description=f"ã“ã‚“ã«ã¡ã¯ã€{target.display_name}ã•ã‚“ï¼\nã“ã®ãƒãƒ£ãƒ³ãƒãƒ«ã§ã‚¿ã‚¹ã‚¯ã®é€šçŸ¥ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚",
                                           color=__dd.Color.blue())
                        await ch.send(embed=intro)
                    except Exception:
                        try: ch = await target.create_dm()
                        except Exception: ch = None

                if ch:
                    emb = __dd.Embed(title=f"ğŸ“‹ {task_name}",
                                     description=f"**æœŸæ—¥: {due_dt.strftime('%Y/%m/%d %H:%M')}**",
                                     color=__dd.Color.gold())
                    try:
                        view = TaskView(tid, target.id, message.author.id, "pending")
                    except Exception:
                        view = None

                    try:
                        main_msg = await ch.send(target.mention, embed=emb, view=view)
                        try:
                            th = await main_msg.create_thread(name=f"ğŸŸ¥ {task_name} - è©³ç´°", auto_archive_duration=60, reason="ã‚¿ã‚¹ã‚¯è©³ç´°")
                            det = __dd.Embed(title="ğŸ“‹ ã‚¿ã‚¹ã‚¯è©³ç´°", color=__dd.Color.blue())
                            det.add_field(name="æŒ‡ç¤ºè€…", value=message.author.mention, inline=True)
                            det.add_field(name="çŠ¶æ…‹", value="ğŸŸ¥ æœªå—è¨—", inline=True)
                            det.add_field(name="ä½œæˆæ—¥æ™‚", value=__dt.datetime.now().strftime("%Y/%m/%d %H:%M"), inline=True)
                            if view is not None:
                                await th.send(embed=det, view=TaskView(tid, target.id, message.author.id, "pending"))
                            else:
                                await th.send(embed=det)
                            # ä¿å­˜
                            try:
                                conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
                                cur.execute("UPDATE tasks SET thread_id=?, message_id=? WHERE id=?", (th.id, main_msg.id, tid))
                                conn.commit(); conn.close()
                            except Exception:
                                pass
                        except Exception:
                            pass
                    except Exception:
                        pass

                created += 1

            await message.reply(f"âœ… {created}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã—ã¾ã—ãŸã€‚" if created else "âŒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
        except Exception as e:
            try:
                await message.reply(f"âŒ è§£æä¸­ã‚¨ãƒ©ãƒ¼: {e}")
            except Exception:
                pass
    logger.info("[assign] fallback_v2 installed via setup_hook")
# ==== /ASSIGN_FALLBACK_V2 ====

# ==== COLOR_COMMANDS_INSTALL (register commands via setup_hook) ====
import sqlite3 as _sq, discord as _dd
from discord.ext import tasks, commands as _cmds

def _emoji_from_status(st): 
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st, "âšª")

async def _rename_thread_to_status(thread: _dd.Thread, status: str):
    try:
        if not isinstance(thread, _dd.Thread): return False
        em=_emoji_from_status(status); cur=thread.name or ""
        for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
            if cur.startswith(e): new=em+cur[len(e):]; break
        else: new=f"{em} {cur}"
        new=new.lstrip()
        if new!=cur: await thread.edit(name=new)
        return True
    except Exception as e:
        try: logger.warning(f"[color] rename failed: {e}")
        except: pass
        return False

# ç›£è¦–ãƒ«ãƒ¼ãƒ—ï¼ˆç„¡ã‘ã‚Œã°ï¼‰
if "color_enforcer" not in globals():
    @tasks.loop(seconds=15)
    async def color_enforcer():
        try:
            conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("""SELECT thread_id,status FROM tasks 
                           WHERE thread_id IS NOT NULL 
                           ORDER BY updated_at DESC, id DESC LIMIT 50""")
            rows=cur.fetchall(); conn.close()
        except Exception as e:
            try: logger.error(f"[color] DB: {e}")
            except: pass
            return
        for thread_id, status in rows:
            ch=bot.get_channel(thread_id)
            if not isinstance(ch,_dd.Thread):
                try: ch=await bot.fetch_channel(thread_id)
                except Exception: continue
            await _rename_thread_to_status(ch, status or "pending")

    @color_enforcer.before_loop
    async def _enf_wait(): 
        await bot.wait_until_ready()

# setup_hook ã§ç¢ºå®Ÿã«ã‚³ãƒãƒ³ãƒ‰ç™»éŒ²
_old_setup_hook = getattr(bot, "setup_hook", None)
@bot.event
async def setup_hook():
    if callable(_old_setup_hook):
        try: await _old_setup_hook()
        except TypeError: pass  # äº’æ›

    # !è‰²ç›´ã™
    async def _fixcolor(ctx):
        if not isinstance(ctx.channel, _dd.Thread):
            await ctx.reply("ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯**ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­**ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"); return
        try:
            conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute("SELECT status FROM tasks WHERE thread_id=?", (ctx.channel.id,))
            row=cur.fetchone(); conn.close()
            if not row:
                await ctx.reply("ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚"); return
            await _rename_thread_to_status(ctx.channel, row[0] or "pending")
            await ctx.reply(f"åŒæœŸã—ã¾ã—ãŸ: {row[0]}")
        except Exception as e:
            try: logger.error(f"[fixcolor] {e}", exc_info=True)
            except: pass
            await ctx.reply("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")

    # !è‰²ç›£è¦–ã‚ªãƒ³ / !è‰²ç›£è¦–ã‚ªãƒ•
    async def _start_enf(ctx):
        if not color_enforcer.is_running():
            color_enforcer.start(); await ctx.reply("è‰²åŒæœŸã®å¸¸é§ã‚’**é–‹å§‹**ã—ã¾ã—ãŸã€‚")
        else: await ctx.reply("è‰²åŒæœŸã¯ã™ã§ã«å‹•ä½œä¸­ã§ã™ã€‚")
    async def _stop_enf(ctx):
        if color_enforcer.is_running():
            color_enforcer.cancel(); await ctx.reply("è‰²åŒæœŸã®å¸¸é§ã‚’**åœæ­¢**ã—ã¾ã—ãŸã€‚")
        else: await ctx.reply("è‰²åŒæœŸã¯åœæ­¢ä¸­ã§ã™ã€‚")

    # æ—¢ã«åŒåãŒã‚ã‚Œã°ä¸Šæ›¸ã
    for cmd_name in ("è‰²ç›´ã™","fixcolor","è‰²ç›£è¦–ã‚ªãƒ³","è‰²ç›£è¦–ã‚ªãƒ•"):
        try: bot.remove_command(cmd_name)
        except Exception: pass

    bot.add_command(_cmds.Command(_fixcolor, name="è‰²ç›´ã™", aliases=["fixcolor"]))
    bot.add_command(_cmds.Command(_start_enf, name="è‰²ç›£è¦–ã‚ªãƒ³"))
    bot.add_command(_cmds.Command(_stop_enf,  name="è‰²ç›£è¦–ã‚ªãƒ•"))
    try: logger.info("[color] commands registered via setup_hook")
    except Exception: pass
# ==== /COLOR_COMMANDS_INSTALL ====

# ==== JP_EMBED_LOCALIZE v2 ====
import discord as _d

_JP_LABEL = {
    "Due Date": "æœŸæ—¥",
    "Due":      "æœŸæ—¥",
    "Status":   "çŠ¶æ…‹",
    "Updated":  "æ›´æ–°",
    "Update":   "æ›´æ–°",
}
_JP_STATUS = {
    "Pending":     "æœªå—è¨—",
    "In Progress": "å—è¨—",
    "Accepted":    "å—è¨—",
    "Completed":   "å®Œäº†",
    "Declined":    "è¾é€€",
    "Problem":     "å•é¡Œ",
    "Abandoned":   "å•é¡Œç™ºç”Ÿ",
}

def _jp_build_localized(emb:_d.Embed, hide_task_id:bool=True)->_d.Embed:
    # åŸºæœ¬æƒ…å ±ã‚’å¼•ãç¶™ã„ã§ã€æ–°ã—ã„Embedã‚’ä½œã‚Šç›´ã™ï¼ˆä¸è¦ãªTask IDã‚‚ã“ã“ã§é™¤å»ï¼‰
    new = _d.Embed(
        title=emb.title, description=emb.description, color=emb.color
    )
    new.url = emb.url
    new.timestamp = emb.timestamp
    if emb.author and emb.author.name:
        new.set_author(name=emb.author.name, url=emb.author.url if emb.author.url else _d.utils.MISSING, icon_url=emb.author.icon_url if emb.author.icon_url else _d.utils.MISSING)
    if emb.footer and emb.footer.text:
        new.set_footer(text=emb.footer.text, icon_url=emb.footer.icon_url if emb.footer.icon_url else _d.utils.MISSING)
    if emb.thumbnail and emb.thumbnail.url:
        new.set_thumbnail(url=emb.thumbnail.url)
    if emb.image and emb.image.url:
        new.set_image(url=emb.image.url)

    for f in emb.fields:
        name = str(f.name).strip()
        value = str(f.value)
        if hide_task_id and name in ("Task ID", "TaskID", "ã‚¿ã‚¹ã‚¯ID"):
            continue
        name_jp = _JP_LABEL.get(name, name)
        if name_jp == "çŠ¶æ…‹":
            value = _JP_STATUS.get(value.strip(), value)
        new.add_field(name=name_jp, value=value, inline=f.inline)
    return new

# BotãŒé€ã£ãŸåŸ‹ã‚è¾¼ã¿ã‚’è‡ªå‹•ã§æ—¥æœ¬èªåŒ–
@bot.listen("on_message")
async def _jp_auto_localize(msg:_d.Message):
    try:
        if msg.author.id != (bot.user.id if bot.user else 0):
            return
        if not msg.embeds:
            return
        emb = msg.embeds[0]
        loc = _jp_build_localized(emb, hide_task_id=True)
        # å¤‰åŒ–ãŒã‚ã‚‹å ´åˆã®ã¿æ›´æ–°ï¼ˆç„¡é§„ãªPATCHã‚’é¿ã‘ã‚‹ï¼‰
        if (emb.fields != loc.fields) or (emb.title != loc.title) or (emb.description != loc.description):
            await msg.edit(embed=loc)
    except Exception:
        pass

# æ‰‹å‹•ä¸€æ‹¬ï¼šç›´è¿‘ã®Botãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’æ—¥æœ¬èªåŒ–ï¼ˆç¾åœ¨ã®ãƒãƒ£ãƒ³ãƒãƒ«ï¼‰
@bot.command(name="æ—¥æœ¬èªåŒ–", aliases=["jp"])
async def cmd_jp(ctx, ä»¶æ•°:int=30):
    try:
        ä»¶æ•° = max(1, min(ä»¶æ•°, 200))
        n = 0
        async for m in ctx.channel.history(limit=ä»¶æ•°):
            if m.author.id == (bot.user.id if bot.user else 0) and m.embeds:
                loc = _jp_build_localized(m.embeds[0], hide_task_id=True)
                await m.edit(embed=loc)
                n += 1
        await ctx.reply(f"æ—¥æœ¬èªåŒ–ã—ã¾ã—ãŸï¼š{n}ä»¶")
    except Exception as e:
        await ctx.reply("æ—¥æœ¬èªåŒ–ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /JP_EMBED_LOCALIZE v2 ====

# ==== DISPLAY_AND_RENAME_AND_NOTIFY ====
import sqlite3 as __sq, discord as __dd, asyncio as __aio
from datetime import datetime as __dt

# --- è¨­å®šï¼ˆDBã«ä¿å­˜ï¼‰ ---
def __cfg_exec(sql, params=(), fetch=False):
    conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
    cur.execute("CREATE TABLE IF NOT EXISTS settings(key TEXT PRIMARY KEY, val TEXT)")
    cur.execute(sql, params)
    rows=cur.fetchall() if fetch else None
    conn.commit(); conn.close()
    return rows

def get_display_mode()->str:
    try:
        r=__cfg_exec("SELECT val FROM settings WHERE key='display_mode'", fetch=True)
        return (r[0][0] if r else "jp")
    except Exception:
        return "jp"

def set_display_mode(mode:str):
    mode = "num" if mode.lower().startswith("num") or mode.startswith("æ•°å­—") else "jp"
    __cfg_exec("INSERT INTO settings(key,val) VALUES('display_mode',?) "
               "ON CONFLICT(key) DO UPDATE SET val=excluded.val", (mode,))
    return mode

# --- æ—¥ä»˜æ–‡å­—åˆ—ã®æ•´å½¢ï¼ˆæ•°å­—/æ—¥æœ¬èªï¼‰ ---
__JP_WD = "æœˆç«æ°´æœ¨é‡‘åœŸæ—¥"
def fmt_due(due)->str:
    # due ã¯ ISO æ–‡å­—åˆ— or datetime or æ—¢å­˜æ–‡å­—åˆ—
    try:
        if isinstance(due, str):
            try:
                d = __dt.fromisoformat(due.replace("Z","+00:00")).replace(tzinfo=None)
            except Exception:
                return due
        elif isinstance(due, __dt):
            d = due
        else:
            return str(due)
        if get_display_mode()=="num":
            return d.strftime("%Y/%m/%d %H:%M")
        else:
            wd = __JP_WD[d.weekday()]
            return d.strftime(f"%Yå¹´%mæœˆ%dæ—¥ï¼ˆ{wd}ï¼‰ %H:%M")
    except Exception:
        return str(due)

# --- çŠ¶æ…‹ã®æ—¥æœ¬èªåŒ–ï¼ˆãƒ©ãƒ™ãƒ«ã¯å›ºå®šã§æ—¥æœ¬èªï¼‰ ---
def jp_status_name(st:str)->str:
    m = {
        "pending":"æœªå—è¨—","accepted":"å—è¨—","completed":"å®Œäº†",
        "declined":"è¾é€€","abandoned":"å•é¡Œç™ºç”Ÿ",
        "In Progress":"å—è¨—","Accepted":"å—è¨—","Completed":"å®Œäº†",
        "Pending":"æœªå—è¨—","Declined":"è¾é€€","Problem":"å•é¡Œ"
    }
    return m.get((st or "").strip(), st)

# --- å€‹äººãƒãƒ£ãƒ³ãƒãƒ«å–å¾—/ä½œæˆ ---
async def get_personal_channel(guild:__dd.Guild, user:__dd.Member):
    name=f"to-{user.display_name}"
    ch=__dd.utils.get(guild.channels, name=name)
    if ch: return ch
    try:
        ow={guild.default_role:__dd.PermissionOverwrite(read_messages=False),
            user:__dd.PermissionOverwrite(read_messages=True, send_messages=True)}
        return await guild.create_text_channel(name, overwrites=ow, topic=f"{user.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
    except Exception:
        try: return await user.create_dm()
        except Exception: return None

# --- å…ˆé ­çµµæ–‡å­—ï¼ˆğŸŸ¥ğŸŸ¨ğŸŸ©âš ï¸âŒï¼‰ ---
def status_emoji(st:str)->str:
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st, "âšª")

# --- ã‚¹ãƒ¬ãƒƒãƒ‰åã‚’çŠ¶æ…‹ã«åˆã‚ã›ã¦æ›´æ–° ---
async def rename_thread_by_status(thread:__dd.Thread, status:str):
    if not isinstance(thread, __dd.Thread): return
    cur = thread.name or ""
    em  = status_emoji(status)
    # ç½®æ›ï¼ä»˜ä¸
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e): new = em + cur[len(e):]; break
    else: new = f"{em} {cur}"
    new=new.lstrip()
    if new!=cur:
        await thread.edit(name=new)

# --- ã‚¢ã‚¯ã‚·ãƒ§ãƒ³â†’çŠ¶æ…‹ ---
def desired_from_action(action:str, db_status:str)->str:
    m = {"accept_task":"accepted","complete_task":"completed",
         "undo_completion":"accepted","abandon_task":"abandoned",
         "decline_task":"declined"}
    return m.get(action, db_status or "pending")

# --- æŒ‡ç¤ºè€…é€šçŸ¥ ---
async def notify_instructor(guild:__dd.Guild, instructor_id:int, assignee_id:int, task_name:str, status:str, due):
    inst = guild.get_member(instructor_id)
    if not inst: return
    ch = await get_personal_channel(guild, inst)
    if not ch: 
        try: await inst.send(embed=emb); return
        except Exception: return
    emb = __dd.Embed(title="ğŸ“£ ã‚¿ã‚¹ã‚¯æ›´æ–°", color=__dd.Color.blue())
    emb.add_field(name="ã‚¿ã‚¹ã‚¯", value=task_name, inline=False)
    emb.add_field(name="çŠ¶æ…‹", value=jp_status_name(status), inline=True)
    emb.add_field(name="æœŸæ—¥", value=fmt_due(due), inline=True)
    emb.add_field(name="æ‹…å½“", value=f"<@{assignee_id}>", inline=True)
    await ch.send(embed=emb)

# --- on_interaction ã§ï¼šã‚¹ãƒ¬ãƒƒãƒ‰åæ›´æ–°ï¼‹æŒ‡ç¤ºè€…é€šçŸ¥ï¼ˆDBã¯è§¦ã‚‰ãªã„ï¼‰ ---
@bot.event
async def setup_hook():
    @bot.listen("on_interaction")
    async def __link_rename_notify(inter:__dd.Interaction):
        try:
            if inter.type != __dd.InteractionType.component: return
            data = inter.data or {}; cid = data.get("custom_id") or ""
            # custom_id: accept_task_123 ãªã©
            import re as __re
            m=__re.match(r'^(accept_task|complete_task|undo_completion|abandon_task|decline_task)_(\d+)$', cid)
            if not m: return
            action, tid = m.group(1), int(m.group(2))

            # å…ƒã®å‡¦ç†ãŒçµ‚ã‚ã‚‹ã¾ã§å°‘ã—å¾…æ©Ÿï¼ˆEmbed/DBæ›´æ–°ã®ç«¶åˆå›é¿ï¼‰
            await __aio.sleep(0.30)

            # DBã‹ã‚‰ instructor/assignee/task_name/due/status/thread_id ã‚’å–å¾—
            try:
                conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
                cur.execute("SELECT instructor_id,assignee_id,task_name,due_date,status,thread_id FROM tasks WHERE id=?", (tid,))
                row=cur.fetchone(); conn.close()
                if not row: return
                instructor_id, assignee_id, task_name, due, db_status, thread_id = row
            except Exception:
                return

            # å¯¾è±¡ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’å–å¾—ï¼ˆthread_idå„ªå…ˆâ†’æ–‡è„ˆã‹ã‚‰è£œå®Œï¼‰
            thread=None
            if thread_id:
                thread = inter.client.get_channel(thread_id)
                if not isinstance(thread, __dd.Thread):
                    try: thread = await inter.client.fetch_channel(thread_id)
                    except Exception: thread=None
            if not isinstance(thread, __dd.Thread):
                thread = inter.message.channel if isinstance(inter.message.channel, __dd.Thread) else getattr(inter.message, "thread", None)

            # æœ›ã¾ã—ã„çŠ¶æ…‹ï¼ˆactionå„ªå…ˆï¼‰
            new_status = desired_from_action(action, db_status)

            # 1) ã‚¹ãƒ¬ãƒƒãƒ‰åæ›´æ–°
            if isinstance(thread, __dd.Thread):
                await rename_thread_by_status(thread, new_status)

            # 2) æŒ‡ç¤ºè€…ã¸é€šçŸ¥ï¼ˆå€‹äººãƒãƒ£ãƒ³ãƒãƒ«ãŒç„¡ã‘ã‚Œã°DMï¼‰
            if inter.guild:
                await notify_instructor(inter.guild, instructor_id, assignee_id, task_name, new_status, due)
        except Exception as e:
            try: logger.error(f"[rename_notify] {e}", exc_info=True)
            except: pass

    # è¡¨ç¤ºå½¢å¼ã®åˆ‡æ›¿ã‚³ãƒãƒ³ãƒ‰ï¼š !è¡¨ç¤º æ—¥æœ¬èª / æ•°å­— / ç¢ºèª
    @bot.command(name="è¡¨ç¤º")
    async def cmd_display(ctx, ãƒ¢ãƒ¼ãƒ‰:str="ç¢ºèª"):
        try:
            if ãƒ¢ãƒ¼ãƒ‰ in ("ç¢ºèª","status","check"):
                cur = get_display_mode()
                await ctx.reply(f"ç¾åœ¨ã®è¡¨ç¤º: **{'æ—¥æœ¬èª' if cur=='jp' else 'æ•°å­—'}**")
                return
            mode = set_display_mode(ãƒ¢ãƒ¼ãƒ‰)
            await ctx.reply(f"è¡¨ç¤ºã‚’ **{'æ—¥æœ¬èª' if mode=='jp' else 'æ•°å­—'}** ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚")
        except Exception as e:
            await ctx.reply("è¡¨ç¤ºè¨­å®šã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
# ==== /DISPLAY_AND_RENAME_AND_NOTIFY ====

# ==== SAFE_ON_MESSAGE ====
# æ—¢å­˜ã® on_message ã‚’å‘¼ã‚“ã ä¸Šã§ã€"!" ã§å§‹ã¾ã‚‹æ™‚ã ã‘ commands ã‚’å‹•ã‹ã™
_old_on_message = getattr(bot, "on_message", None)

@bot.event
async def on_message(message):
    # å…ˆã«æ—¢å­˜ã® on_message ã‚’é€šã™ï¼ˆassign_fallback ãªã©ã®ãƒªã‚¹ãƒŠãƒ¼ã¯ bot.listen ãªã®ã§è‡ªå‹•ã§å‘¼ã°ã‚Œã¾ã™ï¼‰
    if callable(_old_on_message):
        try:
            await _old_on_message(message)
        except TypeError:
            pass

    # Botè‡ªèº«/ä»–Botã¯ç„¡è¦–
    if message.author.bot:
        return

    # "!" ã§å§‹ã¾ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã ã‘ã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦è§£é‡ˆ
    if message.content.lstrip().startswith('!'):
        await bot.process_commands(message)
# ==== /SAFE_ON_MESSAGE ====

# ==== PROCESS_GUARD (process_commands ã‚’ ! å…ˆé ­ã ã‘ã«åˆ¶é™) ====
import asyncio as __a
if not hasattr(bot, "_orig_process_commands"):
    bot._orig_process_commands = bot.process_commands

    async def _guarded_process_commands(message):
        # Botè‡ªèº«/ä»–Botã‚’ç„¡è¦–
        if getattr(message, "author", None) and getattr(message.author, "bot", False):
            return
        # å…ˆé ­ãŒ ! ã®æ™‚ã ã‘ã‚³ãƒãƒ³ãƒ‰ã¨ã—ã¦å‡¦ç†
        content = (message.content or "").lstrip()
        if not content.startswith("!"):
            return
        await bot._orig_process_commands(message)

    bot.process_commands = _guarded_process_commands
# ==== /PROCESS_GUARD ====

# ==== PROBE_ON_MESSAGE ====
@bot.listen("on_message")
async def __probe_om(msg):
    try:
        if msg.author.bot: return
        content = (msg.content or "")
        logger.info(f"[probe] g={getattr(msg.guild,'id',None)} ch={getattr(msg.channel,'id',None)} len={len(content)} bang={bool(content.lstrip().startswith('!'))} mentionBot={bot.user in msg.mentions}")
    except Exception:
        pass
# ==== /PROBE_ON_MESSAGE ====

# ==== PROCESS_GUARD_FINAL ====
if not hasattr(bot, "_orig_process_commands"):
    bot._orig_process_commands = bot.process_commands
    async def _guarded(message):
        if getattr(message.author,'bot',False): return
        content=(message.content or "").lstrip()
        if not content.startswith('!'): return
        await bot._orig_process_commands(message)
    bot.process_commands = _guarded
# ==== /PROCESS_GUARD_FINAL ====

# ==== SLASH_ASSIGN ====
import discord as __d
from discord import app_commands as __ac
import sqlite3 as __sq

# æœŸæ—¥ãƒ‘ãƒ¼ã‚¹ã¯æ—¢å­˜ã® parse_date ã‚’ä½¿ã†å‰æï¼ˆç„¡ã„å ´åˆã¯ "æ˜æ—¥ 18:00" ç­‰ã ã‘ã§ååˆ†ï¼‰
@__ac.command(name="æŒ‡ç¤º", description="æ‹…å½“è€…ã«ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã—ã¾ã™")
@__ac.describe(æ‹…å½“è€…="æ‹…å½“è€…ã‚’é¸æŠ", æœŸæ—¥="ä¾‹: æ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00", ã‚¿ã‚¹ã‚¯å="ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«")
async def slash_assign(inter: __d.Interaction, æ‹…å½“è€…: __d.Member, æœŸæ—¥: str, ã‚¿ã‚¹ã‚¯å: str):
    try:
        # æœŸæ—¥
        try:
            due = parse_date(æœŸæ—¥)
        except Exception:
            due = None
        if not due:
            await inter.response.send_message("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ä¾‹: æ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00", ephemeral=True)
            return

        # DB INSERTï¼ˆlastrowid å–å¾—ï¼‰
        try:
            conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute(
                "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                "VALUES (?,?,?,?,?,?,?)",
                (inter.guild.id, inter.user.id, æ‹…å½“è€….id, ã‚¿ã‚¹ã‚¯å, due, 0, 0)
            )
            tid=cur.lastrowid
            conn.commit(); conn.close()
        except Exception as e:
            try: conn.close()
            except: pass
            await inter.response.send_message("âŒ DBã‚¨ãƒ©ãƒ¼ã§ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚", ephemeral=True)
            return

        # å€‹äººCHé€šçŸ¥ï¼ˆæ—¢å­˜ã®é–¢æ•°ãŒã‚ã‚Œã°ä½¿ç”¨ï¼‰
        try:
            # æ—¢ã«ã‚ãªãŸã®ç’°å¢ƒã«ã‚ã‚‹ send_task_notification ã‚’ä½¿ã†ï¼ˆthreadä½œæˆãƒ»buttonç­‰ï¼‰
            await send_task_notification(inter.guild, æ‹…å½“è€…, inter.user, ã‚¿ã‚¹ã‚¯å, due, 0, task_id=tid)
        except Exception as e:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é€šçŸ¥ï¼ˆæœ€ä½é™ï¼‰
            ch = __d.utils.get(inter.guild.channels, name=f"to-{æ‹…å½“è€….display_name}")
            if not ch:
                try:
                    ow={inter.guild.default_role:__d.PermissionOverwrite(read_messages=False),
                        æ‹…å½“è€…:__d.PermissionOverwrite(read_messages=True, send_messages=True)}
                    ch=await inter.guild.create_text_channel(f"to-{æ‹…å½“è€….display_name}", overwrites=ow,
                                                             topic=f"{æ‹…å½“è€….display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                except Exception:
                    try: ch=await æ‹…å½“è€….create_dm()
                    except: ch=None
            if ch:
                emb=__d.Embed(title=f"ğŸ“‹ {ã‚¿ã‚¹ã‚¯å}",
                               description=f"**æœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}**",
                               color=__d.Color.gold())
                await ch.send(æ‹…å½“è€….mention, embed=emb)

        # é€ä¿¡è€…ã«ã‚‚çµæœã‚’è¿”ã™
        await inter.response.send_message(f"âœ… æŒ‡ç¤ºã—ã¾ã—ãŸï¼š**{æ‹…å½“è€….display_name}** / {ã‚¿ã‚¹ã‚¯å}ï¼ˆæœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}ï¼‰", ephemeral=True)
    except Exception as e:
        try:
            await inter.response.send_message("âŒ å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)
        except Exception:
            pass

# setup_hookã§ç™»éŒ²ï¼†åŒæœŸ
_old_setup_hook = getattr(bot, "setup_hook", None)
@bot.event
async def setup_hook():
    if callable(_old_setup_hook):
        try: await _old_setup_hook()
        except TypeError: pass
    try:
        bot.tree.add_command(slash_assign)
        await bot.tree.sync()
        logger.info("[slash] /æŒ‡ç¤º ã‚’ç™»éŒ²ã—ã¾ã—ãŸ")
    except Exception as e:
        try: logger.error(f"[slash] ç™»éŒ²å¤±æ•—: {e}", exc_info=True)
        except Exception: pass
# ==== /SLASH_ASSIGN ====

# ==== SLASH_ASSIGN (ç¢ºå®Ÿç™»éŒ² + ã‚®ãƒ«ãƒ‰å³æ™‚åŒæœŸ) ====
import discord as _d
from discord import app_commands as _ac
import sqlite3 as _sq

@_ac.command(name="æŒ‡ç¤º", description="æ‹…å½“è€…ã«ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã—ã¾ã™")
@_ac.describe(æ‹…å½“è€…="æ‹…å½“è€…ã‚’é¸æŠ", æœŸæ—¥="ä¾‹: æ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00", ã‚¿ã‚¹ã‚¯å="ã‚¿ã‚¹ã‚¯ã®ã‚¿ã‚¤ãƒˆãƒ«")
async def æŒ‡ç¤º(inter: _d.Interaction, æ‹…å½“è€…: _d.Member, æœŸæ—¥: str, ã‚¿ã‚¹ã‚¯å: str):
    try:
        # æœŸæ—¥ã‚’æ—¢å­˜ãƒ‘ãƒ¼ã‚µã§
        try:
            due = parse_date(æœŸæ—¥)
        except Exception:
            due = None
        if not due:
            await inter.response.send_message("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚\nä¾‹ï¼šæ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00", ephemeral=True)
            return

        # DBç™»éŒ²ï¼ˆlastrowidï¼‰
        try:
            conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
            cur.execute(
                "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                "VALUES (?,?,?,?,?,?,?)",
                (inter.guild.id, inter.user.id, æ‹…å½“è€….id, ã‚¿ã‚¹ã‚¯å, due, 0, 0)
            )
            tid=cur.lastrowid
            conn.commit(); conn.close()
        except Exception:
            try: conn.close()
            except: pass
            await inter.response.send_message("âŒ DBã‚¨ãƒ©ãƒ¼ã§ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚", ephemeral=True)
            return

        # å€‹äººCHé€šçŸ¥ï¼ˆæ—¢å­˜é–¢æ•°ãŒã‚ã‚Œã°åˆ©ç”¨ï¼‰
        try:
            await send_task_notification(inter.guild, æ‹…å½“è€…, inter.user, ã‚¿ã‚¹ã‚¯å, due, 0, task_id=tid)
        except Exception:
            # æœ€ä½é™ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é€šçŸ¥
            ch = _d.utils.get(inter.guild.channels, name=f"to-{æ‹…å½“è€….display_name}")
            if not ch:
                try:
                    ow={inter.guild.default_role:_d.PermissionOverwrite(read_messages=False),
                        æ‹…å½“è€…:_d.PermissionOverwrite(read_messages=True, send_messages=True)}
                    ch=await inter.guild.create_text_channel(f"to-{æ‹…å½“è€….display_name}", overwrites=ow,
                                                             topic=f"{æ‹…å½“è€….display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                except Exception:
                    try: ch=await æ‹…å½“è€….create_dm()
                    except: ch=None
            if ch:
                emb=_d.Embed(title=f"ğŸ“‹ {ã‚¿ã‚¹ã‚¯å}",
                              description=f"**æœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}**",
                              color=_d.Color.gold())
                await ch.send(æ‹…å½“è€….mention, embed=emb)

        await inter.response.send_message(
            f"âœ… æŒ‡ç¤ºã—ã¾ã—ãŸï¼š**{æ‹…å½“è€….display_name}** / {ã‚¿ã‚¹ã‚¯å}ï¼ˆæœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}ï¼‰",
            ephemeral=True
        )
    except Exception as e:
        try: await inter.response.send_message("âŒ å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚", ephemeral=True)
        except Exception: pass

# æ—¢å­˜ setup_hook ãŒã‚ã£ã¦ã‚‚å…±å­˜ã•ã›ã€å…¨å‚åŠ ã‚µãƒ¼ãƒãƒ¼ã«å³æ™‚åŒæœŸ
_old_setup_hook = getattr(bot, "setup_hook", None)
@bot.event
async def setup_hook():
    if callable(_old_setup_hook):
        try: await _old_setup_hook()
        except TypeError: pass

    # ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒ„ãƒªãƒ¼ã«è¿½åŠ ï¼ˆé‡è¤‡ãªã‚‰OKï¼‰
    try:
        try: bot.tree.add_command(æŒ‡ç¤º)
        except Exception: pass

        # å‚åŠ ã—ã¦ã„ã‚‹å„ã‚µãƒ¼ãƒãƒ¼ã«ã‚®ãƒ«ãƒ‰åŒæœŸï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¾…ã¡æ™‚é–“ã‚’å›é¿ï¼‰
        ok=0
        for g in bot.guilds:
            try:
                await bot.tree.sync(guild=_d.Object(id=g.id))
                ok+=1
            except Exception as e:
                try: logger.warning(f"[slash] sync failed in {g.id}: {e}")
                except Exception: pass
        try: logger.info(f"[slash] /æŒ‡ç¤º ã‚’ {ok} guild(s) ã«åŒæœŸã—ã¾ã—ãŸ")
        except Exception: pass
    except Exception as e:
        try: logger.error(f"[slash] ç™»éŒ²å¤±æ•—: {e}", exc_info=True)
        except Exception: pass

# ç®¡ç†è€…å‘ã‘ï¼šæ‰‹å‹•åŒæœŸï¼ˆ/æŒ‡ç¤ºãŒå‡ºãªã„æ™‚ã®æ•‘æ¸ˆï¼‰
@bot.command(name="sync")
@commands.has_permissions(administrator=True)
async def cmd_sync(ctx):
    try:
        cnt=0
        for g in bot.guilds:
            await bot.tree.sync(guild=_d.Object(id=g.id)); cnt+=1
        await ctx.reply(f"Slashã‚³ãƒãƒ³ãƒ‰ã‚’åŒæœŸã—ã¾ã—ãŸï¼ˆ{cnt} guildï¼‰")
    except Exception as e:
        await ctx.reply(f"åŒæœŸã«å¤±æ•—ã—ã¾ã—ãŸï¼š{e}")
# ==== /SLASH_ASSIGN ====

# ==== TEXT_SLASH_ASSIGN_FALLBACK ====
import re as __re, discord as __d, sqlite3 as __sq, datetime as __dt

@bot.listen("on_message")
async def __text_slash_assign(msg: __d.Message):
    """
    æ–‡å­—ã§ `/æŒ‡ç¤º æ‹…å½“è€…:@ã€‡ã€‡ æœŸæ—¥:"â€¦" ã‚¿ã‚¹ã‚¯å:"â€¦"` ã¨æ›¸ã‹ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è§£æã—ã¦å®Ÿè¡Œã€‚
    ä¾‹: /æŒ‡ç¤º æ‹…å½“è€…:@å±±ç”° æœŸæ—¥:"æ˜æ—¥ 18:00" ã‚¿ã‚¹ã‚¯å:"ãƒ¬ãƒãƒ¼ãƒˆæå‡º"
    """
    try:
        if msg.author.bot or (msg.guild is None):
            return
        t = (msg.content or "").strip()
        if not t.startswith("/æŒ‡ç¤º"):
            return

        # æ‹…å½“è€…ã¯ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã‹ã‚‰æ‹¾ã†ï¼ˆæœ€åˆã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰
        assignees = [m for m in msg.mentions if m.id != (bot.user.id if bot.user else 0)]
        if not assignees:
            await msg.reply("âŒ æ‹…å½“è€…ã‚’ @ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ ã—ã¦ãã ã•ã„ã€‚\nä¾‹ï¼‰/æŒ‡ç¤º æ‹…å½“è€…:@å±±ç”° æœŸæ—¥:\"æ˜æ—¥ 18:00\" ã‚¿ã‚¹ã‚¯å:\"ãƒ¬ãƒãƒ¼ãƒˆæå‡º\"")
            return
        assignee = assignees[0]

        # æœŸæ—¥ãƒ»ã‚¿ã‚¹ã‚¯åã¯ æ—¥æœ¬èªã‚­ãƒ¼ + äºŒé‡å¼•ç”¨ç¬¦ ã§æŠœãå‡ºã™
        m_due  = __re.search(r'æœŸæ—¥\s*[:ï¼š]\s*"([^"]+)"', t)
        m_task = __re.search(r'ã‚¿ã‚¹ã‚¯å\s*[:ï¼š]\s*"([^"]+)"', t)
        if not (m_due and m_task):
            await msg.reply("âŒ å½¢å¼ãŒä¸æ­£ã§ã™ã€‚\nä¾‹ï¼‰/æŒ‡ç¤º æ‹…å½“è€…:@å±±ç”° æœŸæ—¥:\"æ˜æ—¥ 18:00\" ã‚¿ã‚¹ã‚¯å:\"ãƒ¬ãƒãƒ¼ãƒˆæå‡º\"")
            return
        due_str  = m_due.group(1).strip()
        task_name = m_task.group(1).strip()

        # æœŸæ—¥ãƒ‘ãƒ¼ã‚¹ï¼ˆæ—¢å­˜ã® parse_date ã‚’ä½¿ç”¨ï¼‰
        try:
            due = parse_date(due_str)
        except Exception:
            due = None
        if not due:
            await msg.reply("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ä¾‹ï¼šæ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00")
            return

        # DB INSERTï¼ˆlastrowid ã‚’å–å¾—ï¼‰
        try:
            conn = __sq.connect('reminder_bot.db'); cur = conn.cursor()
            cur.execute(
                "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                "VALUES (?,?,?,?,?,?,?)",
                (msg.guild.id, msg.author.id, assignee.id, task_name, due, msg.id, msg.channel.id)
            )
            tid = cur.lastrowid
            conn.commit(); conn.close()
        except Exception as e:
            try: conn.close()
            except: pass
            await msg.reply("âŒ DBã‚¨ãƒ©ãƒ¼ã§ä½œæˆã§ãã¾ã›ã‚“ã§ã—ãŸã€‚")
            return

        # å€‹äººãƒãƒ£ãƒ³ãƒãƒ«é€šçŸ¥ï¼ˆæ—¢å­˜ã® send_task_notification ãŒã‚ã‚Œã°ä½¿ã†ï¼‰
        try:
            await send_task_notification(msg.guild, assignee, msg.author, task_name, due, msg.id, task_id=tid)
        except Exception:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆæœ€ä½é™ã®é€šçŸ¥ï¼‰
            ch = __d.utils.get(msg.guild.channels, name=f"to-{assignee.display_name}")
            if not ch:
                try:
                    ow={msg.guild.default_role:__d.PermissionOverwrite(read_messages=False),
                        assignee:__d.PermissionOverwrite(read_messages=True, send_messages=True)}
                    ch = await msg.guild.create_text_channel(f"to-{assignee.display_name}", overwrites=ow,
                                                             topic=f"{assignee.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                except Exception:
                    try: ch = await assignee.create_dm()
                    except: ch=None
            if ch:
                emb=__d.Embed(title=f"ğŸ“‹ {task_name}",
                               description=f"**æœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}**",
                               color=__d.Color.gold())
                await ch.send(assignee.mention, embed=emb)

        await msg.reply(f"âœ… æŒ‡ç¤ºã—ã¾ã—ãŸï¼š**{assignee.display_name}** / {task_name}ï¼ˆæœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}ï¼‰")
    except Exception as e:
        try: logger.error(f"[text /æŒ‡ç¤º] {e}", exc_info=True)
        except: pass
# ==== /TEXT_SLASH_ASSIGN_FALLBACK ====

# ==== PREFIX_ASSIGN_COMMAND ====
import re as _re, sqlite3 as _sq, discord as _dd

@bot.command(name="æŒ‡ç¤º")
async def cmd_assign(ctx):
    """
    ä½¿ã„æ–¹ï¼š!æŒ‡ç¤º @æ‹…å½“è€…1 [@æ‹…å½“è€…2 ...], æœŸæ—¥, ã‚¿ã‚¹ã‚¯å
    ä¾‹ï¼š  !æŒ‡ç¤º @å±±ç”°, æ˜æ—¥ 18:00, ãƒ¬ãƒãƒ¼ãƒˆæå‡º
    """
    try:
        text = ctx.message.content
        # å…ˆé ­ã® "!æŒ‡ç¤º" ã‚’å‰¥ãŒã™
        t = _re.sub(r'^\s*!æŒ‡ç¤º\s*', '', text).strip()
        # ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ä»¥å¤–ã®æ–‡å­—åˆ—ã‹ã‚‰æœ€åˆã®ã‚«ãƒ³ãƒä½ç½®ã‚’æ¢ã™ï¼ˆå…¨è§’/åŠè§’å¯¾å¿œï¼‰
        # å½¢å¼ï¼š @A @B , æœŸæ—¥ , ã‚¿ã‚¹ã‚¯å
        # ã¾ãšãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ç¾¤ã‚’æŒãï¼ˆBotè‡ªèº«ã¯é™¤å¤–ï¼‰
        assignees = [m for m in ctx.message.mentions if m.id != (bot.user.id if bot.user else 0)]
        if not assignees:
            await ctx.reply("âŒ æ‹…å½“è€…ã‚’ @ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ ã—ã¦ãã ã•ã„ã€‚\nä¾‹ï¼š`!æŒ‡ç¤º @å±±ç”°, æ˜æ—¥ 18:00, ãƒ¬ãƒãƒ¼ãƒˆæå‡º`")
            return

        # ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³è¡¨è¨˜ã‚’æœ¬æ–‡ã‹ã‚‰å‰Šé™¤ã—ãŸä¸Šã§ã€ã‚«ãƒ³ãƒã§åˆ†å‰²
        t_wo_mentions = _re.sub(r'<@!?[0-9]+>', '', t).strip()
        parts = [p.strip() for p in _re.split(r'[ï¼Œ,]', t_wo_mentions, maxsplit=2)]
        if len(parts) < 3:
            await ctx.reply("âŒ å½¢å¼ï¼š`!æŒ‡ç¤º @æ‹…å½“è€…, æœŸæ—¥, ã‚¿ã‚¹ã‚¯å`ï¼ˆ**åŠè§’`,` ã‚’2ã¤**ã€‚å…¨è§’ã‚‚å¯ï¼‰")
            return
        due_str, task_name = parts[1], parts[2]
        if not task_name:
            await ctx.reply("âŒ ã‚¿ã‚¹ã‚¯åãŒç©ºã§ã™ã€‚"); return

        # æœŸæ—¥ãƒ‘ãƒ¼ã‚¹ï¼ˆæ—¢å­˜ã® parse_date ã‚’ä½¿ç”¨ï¼‰
        try:
            due = parse_date(due_str)
        except Exception:
            due = None
        if not due:
            await ctx.reply("âŒ æœŸæ—¥ãŒèª­ã‚ã¾ã›ã‚“ã§ã—ãŸã€‚ä¾‹ï¼šæ˜æ—¥ 18:00 / 3æ—¥å¾Œ / é‡‘æ›œ 14:30 / 2025/09/01 09:00")
            return

        created = 0
        for target in assignees:
            # DB Insertï¼ˆlastrowidï¼‰
            try:
                conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
                cur.execute(
                    "INSERT INTO tasks (guild_id,instructor_id,assignee_id,task_name,due_date,message_id,channel_id) "
                    "VALUES (?,?,?,?,?,?,?)",
                    (ctx.guild.id, ctx.author.id, target.id, task_name, due, ctx.message.id, ctx.channel.id)
                )
                tid=cur.lastrowid
                conn.commit(); conn.close()
            except Exception as e:
                try: conn.close()
                except: pass
                continue

            # å€‹äººãƒãƒ£ãƒ³ãƒãƒ«é€šçŸ¥ï¼ˆæ—¢å­˜ã®é–¢æ•°ãŒã‚ã‚Œã°åˆ©ç”¨ï¼‰
            try:
                await send_task_notification(ctx.guild, target, ctx.author, task_name, due, ctx.message.id, task_id=tid)
            except Exception:
                # æœ€ä½é™ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯é€šçŸ¥
                ch = _dd.utils.get(ctx.guild.channels, name=f"to-{target.display_name}")
                if not ch:
                    try:
                        ow={ctx.guild.default_role:_dd.PermissionOverwrite(read_messages=False),
                            target:_dd.PermissionOverwrite(read_messages=True, send_messages=True)}
                        ch=await ctx.guild.create_text_channel(f"to-{target.display_name}", overwrites=ow,
                                                               topic=f"{target.display_name}ã®å€‹äººã‚¿ã‚¹ã‚¯ç®¡ç†ãƒãƒ£ãƒ³ãƒãƒ«")
                    except Exception:
                        try: ch=await target.create_dm()
                        except: ch=None
                if ch:
                    emb=_dd.Embed(title=f"ğŸ“‹ {task_name}",
                                   description=f"**æœŸæ—¥: {due.strftime('%Y/%m/%d %H:%M')}**",
                                   color=_dd.Color.gold())
                    await ch.send(target.mention, embed=emb)

            created += 1

        await ctx.reply(f"âœ… {created}ä»¶ã®ã‚¿ã‚¹ã‚¯ã‚’æŒ‡ç¤ºã—ã¾ã—ãŸã€‚" if created else "âŒ ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
    except Exception as e:
        try: logger.error(f"[cmd_assign] {e}", exc_info=True)
        except: pass
        await ctx.reply("âŒ å®Ÿè¡Œä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /PREFIX_ASSIGN_COMMAND ====

# ==== READY_GUARD_FINAL ====
_ready_fired = False

@bot.event
async def on_ready():
    global _ready_fired
    if _ready_fired:
        return            # å†å…¥ç¦æ­¢ï¼ˆ2å›ç›®ä»¥é™ã¯ä½•ã‚‚ã—ãªã„ï¼‰
    _ready_fired = True

    try:
        logger.info(f'{bot.user} has landed!')
        logger.info(f"Bot is in {len(bot.guilds)} guilds")
    except Exception:
        pass

    # init_database / setup_roles ã¯å­˜åœ¨ã™ã‚Œã°å®Ÿè¡Œï¼ˆç„¡ã‘ã‚Œã°ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    try:
        init_database()
    except Exception as e:
        try: logger.warning(f"[on_ready] init_database skipped: {e}")
        except: pass

    try:
        for g in bot.guilds:
            try: await setup_roles(g)
            except Exception as e:
                try: logger.warning(f"[on_ready] setup_roles skipped in {getattr(g,'id',None)}: {e}")
                except: pass
    except Exception:
        pass
# ==== /READY_GUARD_FINAL ====

# ==== PING_COMMAND ====
@bot.command(name="ping")
async def _ping(ctx):
    try:
        await ctx.reply("pong")
    except Exception as e:
        try: logger.error(f"[ping] {e}", exc_info=True)
        except: pass
# ==== /PING_COMMAND ====

# ==== PRESENCE_KEEPALIVE ====
import discord as _d
from discord.ext import tasks

@tasks.loop(seconds=45)
async def _presence_keepalive():
    try:
        await bot.change_presence(
            status=_d.Status.online,
            activity=_d.Activity(type=_d.ActivityType.watching, name="ã‚¿ã‚¹ã‚¯å—ä»˜ä¸­")
        )
    except Exception:
        pass

@_presence_keepalive.before_loop
async def _presence_wait():  # Botæº–å‚™ã¾ã§å¾…ã¤
    await bot.wait_until_ready()

# setup_hook ãŒã‚ã£ã¦ã‚‚ç„¡ãã¦ã‚‚å‹•ãã‚ˆã†ã«å®‰å…¨ã«é–‹å§‹
_old_setup_hook = getattr(bot, "setup_hook", None)
@bot.event
async def setup_hook():
    if callable(_old_setup_hook):
        try: await _old_setup_hook()
        except TypeError: pass
    if not _presence_keepalive.is_running():
        _presence_keepalive.start()
# ==== /PRESENCE_KEEPALIVE ====

# ==== PRESENCE_KEEPALIVE ====
import discord as _d
from discord.ext import tasks

@tasks.loop(seconds=45)
async def _presence_keepalive():
    try:
        await bot.change_presence(
            status=_d.Status.online,
            activity=_d.Activity(type=_d.ActivityType.watching, name="ã‚¿ã‚¹ã‚¯å—ä»˜ä¸­")
        )
    except Exception:
        pass

@_presence_keepalive.before_loop
async def _presence_wait():  # Botæº–å‚™ã¾ã§å¾…ã¤
    await bot.wait_until_ready()

# setup_hook ãŒã‚ã£ã¦ã‚‚ç„¡ãã¦ã‚‚å‹•ãã‚ˆã†ã«å®‰å…¨ã«é–‹å§‹
_old_setup_hook = getattr(bot, "setup_hook", None)
@bot.event
async def setup_hook():
    if callable(_old_setup_hook):
        try: await _old_setup_hook()
        except TypeError: pass
    if not _presence_keepalive.is_running():
        _presence_keepalive.start()
# ==== /PRESENCE_KEEPALIVE ====

# ==== READY_OVERRIDE_HARD ====
_ready_once = False
async def __safe_ready():
    global _ready_once
    if _ready_once:
        return
    _ready_once = True
    try:
        logger.info(f"{bot.user} has landed!")
        logger.info(f"Bot is in {len(bot.guilds)} guilds")
    except Exception:
        pass
    # init_database / setup_roles ã¯å­˜åœ¨ã™ã‚Œã°å®Ÿæ–½ã€ç„¡ã‘ã‚Œã°é™ã‹ã«ã‚¹ã‚­ãƒƒãƒ—
    try:
        init_database()
    except Exception as e:
        try: logger.warning(f"[on_ready] init_database skipped: {e}")
        except: pass
    try:
        for g in bot.guilds:
            try: await setup_roles(g)
            except Exception as e:
                try: logger.warning(f"[on_ready] setup_roles skipped in {getattr(g,'id',None)}: {e}")
                except: pass
    except Exception:
        pass

# ã™ã¹ã¦ã®æ—¢å­˜ on_ready ã‚’ç„¡è¦–ã—ã¦ã€ã“ã®é–¢æ•°ã«å¼·åˆ¶å·®ã—æ›¿ãˆ
bot.on_ready = __safe_ready
# ==== /READY_OVERRIDE_HARD ====

# ==== HARD_KILL_READY (on_ready ãƒ«ãƒ¼ãƒ—åœæ­¢ãƒ»ä¸€å›ã ã‘å®Ÿè¡Œ) ====
import types as __types

# å®‰å…¨ãª on_ready æœ¬ä½“ï¼ˆ1å›ã ã‘å‹•ãï¼‰
_ready_once = False
async def __safe_ready_impl():
    global _ready_once
    if _ready_once:  # 2å›ç›®ä»¥é™ã¯ä½•ã‚‚ã—ãªã„
        return
    _ready_once = True
    try:
        logger.info(f"{bot.user} has landed!")
        logger.info(f"Bot is in {len(bot.guilds)} guilds")
    except Exception:
        pass
    # init_database / setup_roles ã¯å­˜åœ¨ã™ã‚Œã°å®Ÿè¡Œï¼ˆç„¡ã‘ã‚Œã°é»™ã£ã¦ã‚¹ã‚­ãƒƒãƒ—ï¼‰
    try:
        init_database()
    except Exception as e:
        try: logger.warning(f"[ready] init_database skipped: {e}")
        except: pass
    try:
        for g in bot.guilds:
            try: await setup_roles(g)
            except Exception as e:
                try: logger.warning(f"[ready] setup_roles skipped in {getattr(g,'id',None)}: {e}")
                except: pass
    except Exception:
        pass

# Client._run_event ã‚’ãƒ‘ãƒƒãƒã—ã¦ on_ready ã¯ __safe_ready_impl ã ã‘ã«ã™ã‚‹
if not hasattr(bot, "_orig__run_event"):
    bot._orig__run_event = bot._run_event
    async def __patched__run_event(self, coro, event_name, *args, **kwargs):
        if event_name == "on_ready":
            await __safe_ready_impl()
            return  # ä»–ã® on_ready ã¯å‘¼ã°ãªã„ï¼ˆãƒ«ãƒ¼ãƒ—åœæ­¢ï¼‰
        return await bot._orig__run_event(coro, event_name, *args, **kwargs)
    bot._run_event = __types.MethodType(__patched__run_event, bot)
# ==== /HARD_KILL_READY ====

if __name__ == "__main__":
    import os
    TOKEN = os.getenv("DISCORD_BOT_TOKEN")
    if not TOKEN:
        logger.error("DISCORD_BOT_TOKEN environment variable not set")
        exit(1)
    
    try:
        logger.info("Bot starting...")
        bot.run(TOKEN)
    except KeyboardInterrupt:
        logger.info("Bot stopped by user")
    except Exception as e:
        logger.error(f"Bot crashed: {e}")
        exit(1)
# ---- Minimal DatabaseManager (fallback) ----
class DatabaseManager:
    @staticmethod
    def execute_query(query: str, params: tuple = ()):
        conn = sqlite3.connect('reminder_bot.db')
        cur = conn.cursor()
        try:
            cur.execute(query, params)
            rows = cur.fetchall()
            conn.commit()
            return rows
        except Exception as e:
            logger.error(f"DB error: {e}")
            conn.rollback()
            return []
        finally:
            conn.close()
# -------------------------------------------
# ==== INIT_DB_RESTORE ====
def init_database():
    import sqlite3
    conn = sqlite3.connect('reminder_bot.db')
    cur = conn.cursor()

    # admins
    cur.execute("""
        CREATE TABLE IF NOT EXISTS admins (
            user_id INTEGER,
            guild_id INTEGER,
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (user_id, guild_id)
        )
    """)

    # instructors
    cur.execute("""
        CREATE TABLE IF NOT EXISTS instructors (
            user_id INTEGER,
            guild_id INTEGER,
            target_users TEXT,
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY (user_id, guild_id)
        )
    """)

    # tasksï¼ˆåŸºæœ¬ã‚«ãƒ©ãƒ ï¼‹ã‚ã¨ã§ä¸è¶³åˆ†ã‚’ALTERã§è£œå®Œï¼‰
    cur.execute("""
        CREATE TABLE IF NOT EXISTS tasks (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            guild_id INTEGER,
            instructor_id INTEGER,
            assignee_id INTEGER,
            task_name TEXT,
            due_date TIMESTAMP,
            status TEXT DEFAULT 'pending',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            message_id INTEGER,
            channel_id INTEGER,
            reminder_sent INTEGER DEFAULT 0,
            thread_id INTEGER
        )
    """)

    # notification_channels
    cur.execute("""
        CREATE TABLE IF NOT EXISTS notification_channels (
            guild_id INTEGER,
            user_id INTEGER,
            channel_id INTEGER,
            channel_type TEXT,
            PRIMARY KEY (guild_id, user_id, channel_type)
        )
    """)

    # æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«ã«ä¸è¶³ã‚«ãƒ©ãƒ ãŒã‚ã‚Œã°è¿½åŠ ï¼ˆå¤±æ•—ã¯ç„¡è¦–ï¼‰
    try:
        cur.execute("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")
    except Exception:
        pass
    try:
        cur.execute("ALTER TABLE tasks ADD COLUMN thread_id INTEGER")
    except Exception:
        pass

    conn.commit()
    conn.close()
    try:
        logger.info("[init] database ready")
    except Exception:
        pass
# ==== /INIT_DB_RESTORE ====
# ==== SETUP_ROLES_RESTORE ====
import discord as _d

async def setup_roles(guild: _d.Guild):
    """ã‚µãƒ¼ãƒãƒ¼ã« 'ã‚¿ã‚¹ã‚¯ç®¡ç†è€…' / 'ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…' ã‚’ä½œæˆï¼ˆç„¡ã‘ã‚Œã°ï¼‰"""
    try:
        admin = _d.utils.get(guild.roles, name="ã‚¿ã‚¹ã‚¯ç®¡ç†è€…")
        if not admin:
            admin = await guild.create_role(
                name="ã‚¿ã‚¹ã‚¯ç®¡ç†è€…", color=_d.Color.red(), hoist=True, reason="reminder bot setup"
            )
        instructor = _d.utils.get(guild.roles, name="ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…")
        if not instructor:
            instructor = await guild.create_role(
                name="ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…", color=_d.Color.blue(), hoist=True, reason="reminder bot setup"
            )
        try:
            logger.info(f"[setup_roles] ready in {guild.name}")
        except Exception:
            pass
        return admin, instructor
    except Exception as e:
        try:
            logger.error(f"[setup_roles] error: {e}", exc_info=True)
        except Exception:
            pass
        return None, None
# ==== /SETUP_ROLES_RESTORE ====
# ==== COLOR_ENFORCER ====
import asyncio as _aio, sqlite3 as _sq, discord as _dd

def _emoji_from_status(st: str) -> str:
    return {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(st, "âšª")

async def _rename_thread_to_status(thread: _dd.Thread, status: str):
    try:
        if not isinstance(thread, _dd.Thread):
            return False
        em = _emoji_from_status(status)
        cur = thread.name or ""
        # å…ˆé ­çµµæ–‡å­—ã‚’ç½®æ›/ä»˜ä¸
        for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
            if cur.startswith(e):
                new = em + cur[len(e):]
                break
        else:
            new = f"{em} {cur}"
        new = new.lstrip()
        if new != cur:
            await thread.edit(name=new)
        return True
    except Exception as e:
        try: logger.warning(f"[enforcer] rename failed: {e}")
        except: pass
        return False

from discord.ext import tasks

@tasks.loop(seconds=15)
async def color_enforcer():
    """DBä¸Šã®statusã¨ã‚¹ãƒ¬ãƒƒãƒ‰åã®å…ˆé ­çµµæ–‡å­—ã‚’åŒæœŸã™ã‚‹ï¼ˆæœ€è¿‘æ›´æ–°ã®ã‚¿ã‚¹ã‚¯ã®ã¿ï¼‰"""
    try:
        conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
        # ç›´è¿‘æ›´æ–°50ä»¶ç¨‹åº¦ã«é™å®šï¼ˆãƒ¬ãƒ¼ãƒˆåˆ¶é™å›é¿ï¼‰
        cur.execute("""
            SELECT id, thread_id, status
            FROM tasks
            WHERE thread_id IS NOT NULL
            ORDER BY updated_at DESC, id DESC
            LIMIT 50
        """)
        rows=cur.fetchall(); conn.close()
    except Exception as e:
        try: logger.error(f"[enforcer] DB error: {e}")
        except: pass
        return

    for tid, thread_id, status in rows:
        ch = bot.get_channel(thread_id)
        if not isinstance(ch, _dd.Thread):
            try:
                ch = await bot.fetch_channel(thread_id)
            except Exception:
                continue
        ok = await _rename_thread_to_status(ch, status or "pending")
        # é€£ç¶šPATCHã‚’é¿ã‘ã‚‹ãŸã‚ã«å°‘ã—é–“éš”ã‚’ã‚ã‘ã‚‹
        await _aio.sleep(0.35)

@color_enforcer.before_loop
async def _enforcer_wait_ready():
    await bot.wait_until_ready()

# æ‰‹å‹•ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆä¿®æ­£ï¼šç¾åœ¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã ã‘å³åŒæœŸ
@bot.command(name='è‰²ç›´ã™', aliases=['fixcolor'])
async def cmd_fixcolor(ctx):
    """ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­ã§å®Ÿè¡Œï¼‰ã‚¹ãƒ¬ãƒƒãƒ‰åã®è‰²ã‚’DBã®statusã«åˆã‚ã›ã¦å³åŒæœŸ"""
    try:
        if not isinstance(ctx.channel, _dd.Thread):
            await ctx.reply("ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯**ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­**ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
            return
        conn=_sq.connect('reminder_bot.db'); cur=conn.cursor()
        cur.execute("SELECT status FROM tasks WHERE thread_id=?", (ctx.channel.id,))
        row=cur.fetchone(); conn.close()
        if not row:
            await ctx.reply("ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«å¯¾å¿œã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
            return
        status=row[0] or "pending"
        await _rename_thread_to_status(ctx.channel, status)
        await ctx.reply(f"åŒæœŸã—ã¾ã—ãŸï¼š {status}")
    except Exception as e:
        try: logger.error(f"[fixcolor] error: {e}", exc_info=True)
        except: pass
        await ctx.reply("ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")

# å¸¸é§ã®é–‹å§‹/åœæ­¢ï¼ˆç®¡ç†è€…ï¼‰
@bot.command(name='è‰²ç›£è¦–ã‚ªãƒ³')
@commands.has_permissions(administrator=True)
async def cmd_start_enforcer(ctx):
    if not color_enforcer.is_running():
        color_enforcer.start()
        await ctx.reply("è‰²åŒæœŸã®å¸¸é§ã‚’**é–‹å§‹**ã—ã¾ã—ãŸã€‚")
    else:
        await ctx.reply("è‰²åŒæœŸã¯ã™ã§ã«å‹•ä½œä¸­ã§ã™ã€‚")

@bot.command(name='è‰²ç›£è¦–ã‚ªãƒ•')
@commands.has_permissions(administrator=True)
async def cmd_stop_enforcer(ctx):
    if color_enforcer.is_running():
        color_enforcer.cancel()
        await ctx.reply("è‰²åŒæœŸã®å¸¸é§ã‚’**åœæ­¢**ã—ã¾ã—ãŸã€‚")
    else:
        await ctx.reply("è‰²åŒæœŸã¯åœæ­¢ä¸­ã§ã™ã€‚")
# ==== /COLOR_ENFORCER ====
# ==== BIND_THREAD_TO_TASK (æ‰‹å‹•ç´ä»˜ã‘) ====
import sqlite3 as __sq, discord as __dd

async def __helper_read_status_by_id(tid:int):
    try:
        c=__sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT status FROM tasks WHERE id=?", (tid,))
        r=c.fetchone(); c.connection.close()
        return (r[0] if r else None) or "pending"
    except Exception:
        return "pending"

# æ—¢ã« COLOR_ENFORCER ã‚’å…¥ã‚Œã¦ã„ã‚Œã° _rename_thread_to_status ãŒä½¿ãˆã‚‹ã€‚
# ç„¡ã„ç’°å¢ƒã§ã‚‚å‹•ãã‚ˆã†ã«æœ€å°ç‰ˆã‚’ç”¨æ„ã—ã¦ãŠãã€‚
async def __rename_min(thread: __dd.Thread, status: str):
    em = {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(status,"âšª")
    cur = thread.name or ""
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e):
            new = em + cur[len(e):]; break
    else:
        new = f"{em} {cur}"
    new = new.lstrip()
    if new != cur:
        await thread.edit(name=new)

@bot.command(name='ç´ä»˜ã‘', aliases=['bind'])
async def bind_thread_command(ctx, task_id: int):
    """ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰å†…ï¼‰ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æŒ‡å®šTask IDã«ç´ä»˜ã‘ã¦ã€è‰²ã‚‚å³åŒæœŸã—ã¾ã™"""
    try:
        if not isinstance(ctx.channel, __dd.Thread):
            await ctx.reply("ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯**ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­**ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
            return

        # DBã« thread_id ã‚’ä¿å­˜
        conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
        cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (ctx.channel.id, task_id))
        if cur.rowcount == 0:
            conn.commit(); conn.close()
            await ctx.reply(f"âŒ Task ID {task_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
            return
        conn.commit(); conn.close()

        # ç›´ã¡ã«è‰²ã‚’åŒæœŸ
        status = await __helper_read_status_by_id(task_id)
        try:
            # æ—¢ã«ã‚ã‚‹ helper ãŒã‚ã‚Œã°ä½¿ã†
            if '_rename_thread_to_status' in globals():
                await _rename_thread_to_status(ctx.channel, status)
            else:
                await __rename_min(ctx.channel, status)
        except Exception:
            await __rename_min(ctx.channel, status)

        await ctx.reply(f"âœ… ç´ä»˜ã‘å®Œäº†ï¼ˆTask ID {task_id} / status={status}ï¼‰")
    except Exception as e:
        try: logger.error(f"[bind] error: {e}", exc_info=True)
        except: pass
        await ctx.reply("âŒ ç´ä»˜ã‘ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /BIND_THREAD_TO_TASK ====
# ==== BIND_THREAD_TO_TASK (æ‰‹å‹•ç´ä»˜ã‘) ====
import sqlite3 as __sq, discord as __dd

async def __helper_read_status_by_id(tid:int):
    try:
        c=__sq.connect('reminder_bot.db').cursor()
        c.execute("SELECT status FROM tasks WHERE id=?", (tid,))
        r=c.fetchone(); c.connection.close()
        return (r[0] if r else None) or "pending"
    except Exception:
        return "pending"

# æ—¢ã« COLOR_ENFORCER ã‚’å…¥ã‚Œã¦ã„ã‚Œã° _rename_thread_to_status ãŒä½¿ãˆã‚‹ã€‚
# ç„¡ã„ç’°å¢ƒã§ã‚‚å‹•ãã‚ˆã†ã«æœ€å°ç‰ˆã‚’ç”¨æ„ã—ã¦ãŠãã€‚
async def __rename_min(thread: __dd.Thread, status: str):
    em = {"pending":"ğŸŸ¥","accepted":"ğŸŸ¨","completed":"ğŸŸ©","abandoned":"âš ï¸","declined":"âŒ"}.get(status,"âšª")
    cur = thread.name or ""
    for e in ("ğŸŸ¥","ğŸŸ¨","ğŸŸ©","âš ï¸","âŒ","âšª"):
        if cur.startswith(e):
            new = em + cur[len(e):]; break
    else:
        new = f"{em} {cur}"
    new = new.lstrip()
    if new != cur:
        await thread.edit(name=new)

@bot.command(name='ç´ä»˜ã‘', aliases=['bind'])
async def bind_thread_command(ctx, task_id: int):
    """ï¼ˆã‚¹ãƒ¬ãƒƒãƒ‰å†…ï¼‰ã“ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’æŒ‡å®šTask IDã«ç´ä»˜ã‘ã¦ã€è‰²ã‚‚å³åŒæœŸã—ã¾ã™"""
    try:
        if not isinstance(ctx.channel, __dd.Thread):
            await ctx.reply("ã“ã®ã‚³ãƒãƒ³ãƒ‰ã¯**ã‚¹ãƒ¬ãƒƒãƒ‰ã®ä¸­**ã§å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚")
            return

        # DBã« thread_id ã‚’ä¿å­˜
        conn=__sq.connect('reminder_bot.db'); cur=conn.cursor()
        cur.execute("UPDATE tasks SET thread_id=? WHERE id=?", (ctx.channel.id, task_id))
        if cur.rowcount == 0:
            conn.commit(); conn.close()
            await ctx.reply(f"âŒ Task ID {task_id} ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚")
            return
        conn.commit(); conn.close()

        # ç›´ã¡ã«è‰²ã‚’åŒæœŸ
        status = await __helper_read_status_by_id(task_id)
        try:
            # æ—¢ã«ã‚ã‚‹ helper ãŒã‚ã‚Œã°ä½¿ã†
            if '_rename_thread_to_status' in globals():
                await _rename_thread_to_status(ctx.channel, status)
            else:
                await __rename_min(ctx.channel, status)
        except Exception:
            await __rename_min(ctx.channel, status)

        await ctx.reply(f"âœ… ç´ä»˜ã‘å®Œäº†ï¼ˆTask ID {task_id} / status={status}ï¼‰")
    except Exception as e:
        try: logger.error(f"[bind] error: {e}", exc_info=True)
        except: pass
        await ctx.reply("âŒ ç´ä»˜ã‘ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚")
# ==== /BIND_THREAD_TO_TASK ====
# ==== INIT_DB_AND_ROLES (æ—¥æœ¬èªç‰ˆ/ã‚¨ãƒ©ãƒ¼å®‰å…¨) ====
def init_database():
    """SQLiteã®ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ä½œæˆï¼ä¸è¶³ã‚«ãƒ©ãƒ ã¯è¿½åŠ ã—ã¦ãŠã"""
    import sqlite3, logging
    log = logging.getLogger(__name__)
    conn = sqlite3.connect('reminder_bot.db')
    cur  = conn.cursor()

    # ç®¡ç†è€…
    cur.execute("""
        CREATE TABLE IF NOT EXISTS admins(
            user_id INTEGER,
            guild_id INTEGER,
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY(user_id, guild_id)
        )
    """)

    # æŒ‡ç¤ºè€…
    cur.execute("""
        CREATE TABLE IF NOT EXISTS instructors(
            user_id INTEGER,
            guild_id INTEGER,
            target_users TEXT,
            added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            PRIMARY KEY(user_id, guild_id)
        )
    """)

    # ã‚¿ã‚¹ã‚¯ï¼ˆthread_id ã‚‚æŒã¤ï¼‰
    cur.execute("""
        CREATE TABLE IF NOT EXISTS tasks(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            guild_id INTEGER,
            instructor_id INTEGER,
            assignee_id INTEGER,
            task_name TEXT,
            due_date TIMESTAMP,
            status TEXT DEFAULT 'pending',
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            message_id INTEGER,
            channel_id INTEGER,
            reminder_sent INTEGER DEFAULT 0,
            thread_id INTEGER
        )
    """)

    # é€šçŸ¥ãƒãƒ£ãƒ³ãƒãƒ«
    cur.execute("""
        CREATE TABLE IF NOT EXISTS notification_channels(
            guild_id INTEGER,
            user_id INTEGER,
            channel_id INTEGER,
            channel_type TEXT,
            PRIMARY KEY(guild_id, user_id, channel_type)
        )
    """)

    # æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸è¶³ã‚«ãƒ©ãƒ è£œå®Œï¼ˆå¤±æ•—ã¯ç„¡è¦–ï¼‰
    try: cur.execute("ALTER TABLE tasks ADD COLUMN reminder_sent INTEGER DEFAULT 0")
    except Exception: pass
    try: cur.execute("ALTER TABLE tasks ADD COLUMN thread_id INTEGER")
    except Exception: pass

    conn.commit(); conn.close()
    try: log.info("[init] ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–å®Œäº†")
    except Exception: pass


import discord as _d
async def setup_roles(guild: _d.Guild):
    """ã‚µãƒ¼ãƒãƒ¼ã« 'ã‚¿ã‚¹ã‚¯ç®¡ç†è€…' / 'ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…' ã‚’ä½œæˆï¼ˆç„¡ã‘ã‚Œã°ï¼‰"""
    try:
        admin = _d.utils.get(guild.roles, name="ã‚¿ã‚¹ã‚¯ç®¡ç†è€…")
        if not admin:
            admin = await guild.create_role(
                name="ã‚¿ã‚¹ã‚¯ç®¡ç†è€…", color=_d.Color.red(), hoist=True, reason="reminder bot setup"
            )
        instructor = _d.utils.get(guild.roles, name="ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…")
        if not instructor:
            instructor = await guild.create_role(
                name="ã‚¿ã‚¹ã‚¯æŒ‡ç¤ºè€…", color=_d.Color.blue(), hoist=True, reason="reminder bot setup"
            )
        try: logger.info(f"[setup_roles] ãƒ­ãƒ¼ãƒ«æº–å‚™å®Œäº† in {guild.name}")
        except Exception: pass
        return admin, instructor
    except Exception as e:
        try: logger.error(f"[setup_roles] ã‚¨ãƒ©ãƒ¼: {e}", exc_info=True)
        except Exception: pass
        return None, None
# ==== /INIT_DB_AND_ROLES ====
